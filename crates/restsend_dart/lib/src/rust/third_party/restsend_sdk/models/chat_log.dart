// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from_str`, `from`, `from`, `from`, `lower_return`, `lower_return`, `lower_return`, `lower_return`, `lower_return`, `lower`, `lower`, `lower`, `lower`, `lower`, `lower`, `lower`, `lower`, `lower`, `lower`, `to_string`, `to_string`, `try_convert_unexpected_callback_error`, `try_convert_unexpected_callback_error`, `try_convert_unexpected_callback_error`, `try_convert_unexpected_callback_error`, `try_convert_unexpected_callback_error`, `try_lift_successful_return`, `try_lift_successful_return`, `try_lift_successful_return`, `try_lift_successful_return`, `try_lift_successful_return`, `try_lift`, `try_lift`, `try_lift`, `try_lift`, `try_lift`, `try_lift`, `try_lift`, `try_lift`, `try_lift`, `try_lift`, `try_read`, `try_read`, `try_read`, `try_read`, `try_read`, `try_read`, `try_read`, `try_read`, `try_read`, `try_read`, `write`, `write`, `write`, `write`, `write`, `write`, `write`, `write`, `write`, `write`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContentType>>
abstract class ContentType implements RustOpaqueInterface {}

class Attachment {
  /// if url is not empty, it means the attachment is from remote, without upload
  final String url;
  final PlatformInt64 size;
  final String thumbnail;
  final String fileName;
  final String filePath;
  final String urlOrData;
  final bool isPrivate;
  final AttachmentStatus status;

  const Attachment({
    required this.url,
    required this.size,
    required this.thumbnail,
    required this.fileName,
    required this.filePath,
    required this.urlOrData,
    required this.isPrivate,
    required this.status,
  });

  static Future<Attachment> default_() =>
      RustLib.instance.api.restsendSdkModelsChatLogAttachmentDefault();

  static Future<Attachment> fromLocal(
          {required String fileName,
          required String filePath,
          required bool isPrivate}) =>
      RustLib.instance.api.restsendSdkModelsChatLogAttachmentFromLocal(
          fileName: fileName, filePath: filePath, isPrivate: isPrivate);

  static Future<Attachment> fromUrl(
          {required String url,
          required bool isPrivate,
          required PlatformInt64 size}) =>
      RustLib.instance.api.restsendSdkModelsChatLogAttachmentFromUrl(
          url: url, isPrivate: isPrivate, size: size);

  @override
  int get hashCode =>
      url.hashCode ^
      size.hashCode ^
      thumbnail.hashCode ^
      fileName.hashCode ^
      filePath.hashCode ^
      urlOrData.hashCode ^
      isPrivate.hashCode ^
      status.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Attachment &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          size == other.size &&
          thumbnail == other.thumbnail &&
          fileName == other.fileName &&
          filePath == other.filePath &&
          urlOrData == other.urlOrData &&
          isPrivate == other.isPrivate &&
          status == other.status;
}

enum AttachmentStatus {
  toUpload,
  toDownload,
  uploading,
  downloading,
  paused,
  done,
  failed,
  ;

  static Future<AttachmentStatus> default_() =>
      RustLib.instance.api.restsendSdkModelsChatLogAttachmentStatusDefault();
}

class ChatLog {
  final String topicId;
  final String id;
  final PlatformInt64 seq;
  final String createdAt;
  final String senderId;
  final Content content;
  final bool read;
  final bool recall;
  final ChatLogStatus status;
  final PlatformInt64 cachedAt;

  const ChatLog({
    required this.topicId,
    required this.id,
    required this.seq,
    required this.createdAt,
    required this.senderId,
    required this.content,
    required this.read,
    required this.recall,
    required this.status,
    required this.cachedAt,
  });

  static Future<ChatLog> default_() =>
      RustLib.instance.api.restsendSdkModelsChatLogChatLogDefault();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<ChatLog> newInstance(
          {required String topicId, required String id}) =>
      RustLib.instance.api
          .restsendSdkModelsChatLogChatLogNew(topicId: topicId, id: id);

  Future<PlatformInt64> sortKey() =>
      RustLib.instance.api.restsendSdkModelsChatLogChatLogSortKey(
        that: this,
      );

  @override
  int get hashCode =>
      topicId.hashCode ^
      id.hashCode ^
      seq.hashCode ^
      createdAt.hashCode ^
      senderId.hashCode ^
      content.hashCode ^
      read.hashCode ^
      recall.hashCode ^
      status.hashCode ^
      cachedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChatLog &&
          runtimeType == other.runtimeType &&
          topicId == other.topicId &&
          id == other.id &&
          seq == other.seq &&
          createdAt == other.createdAt &&
          senderId == other.senderId &&
          content == other.content &&
          read == other.read &&
          recall == other.recall &&
          status == other.status &&
          cachedAt == other.cachedAt;
}

enum ChatLogStatus {
  uploading,
  sending,
  sent,
  downloading,
  received,
  read,
  sendFailed,
  ;

  static Future<ChatLogStatus> default_() =>
      RustLib.instance.api.restsendSdkModelsChatLogChatLogStatusDefault();
}

class Content {
  final String contentType;
  final bool encrypted;
  final int checksum;
  final String text;
  final String placeholder;
  final String thumbnail;
  final String duration;
  final BigInt size;
  final double width;
  final double height;
  final List<String> mentions;
  final bool mentionAll;
  final String reply;
  final String? replyContent;
  final String createdAt;
  final Attachment? attachment;
  final Map<String, String>? extra;
  final bool unreadable;

  const Content({
    required this.contentType,
    required this.encrypted,
    required this.checksum,
    required this.text,
    required this.placeholder,
    required this.thumbnail,
    required this.duration,
    required this.size,
    required this.width,
    required this.height,
    required this.mentions,
    required this.mentionAll,
    required this.reply,
    this.replyContent,
    required this.createdAt,
    this.attachment,
    this.extra,
    required this.unreadable,
  });

  static Future<Content> default_() =>
      RustLib.instance.api.restsendSdkModelsChatLogContentDefault();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<Content> newInstance({required ContentType contentType}) =>
      RustLib.instance.api
          .restsendSdkModelsChatLogContentNew(contentType: contentType);

  static Future<Content> newText(
          {required ContentType contentType, required String text}) =>
      RustLib.instance.api.restsendSdkModelsChatLogContentNewText(
          contentType: contentType, text: text);

  @override
  int get hashCode =>
      contentType.hashCode ^
      encrypted.hashCode ^
      checksum.hashCode ^
      text.hashCode ^
      placeholder.hashCode ^
      thumbnail.hashCode ^
      duration.hashCode ^
      size.hashCode ^
      width.hashCode ^
      height.hashCode ^
      mentions.hashCode ^
      mentionAll.hashCode ^
      reply.hashCode ^
      replyContent.hashCode ^
      createdAt.hashCode ^
      attachment.hashCode ^
      extra.hashCode ^
      unreadable.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Content &&
          runtimeType == other.runtimeType &&
          contentType == other.contentType &&
          encrypted == other.encrypted &&
          checksum == other.checksum &&
          text == other.text &&
          placeholder == other.placeholder &&
          thumbnail == other.thumbnail &&
          duration == other.duration &&
          size == other.size &&
          width == other.width &&
          height == other.height &&
          mentions == other.mentions &&
          mentionAll == other.mentionAll &&
          reply == other.reply &&
          replyContent == other.replyContent &&
          createdAt == other.createdAt &&
          attachment == other.attachment &&
          extra == other.extra &&
          unreadable == other.unreadable;
}
