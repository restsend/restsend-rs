// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`, `from_str`, `lower_return`, `lower_return`, `lower`, `lower`, `lower`, `lower`, `to_string`, `try_convert_unexpected_callback_error`, `try_convert_unexpected_callback_error`, `try_lift_successful_return`, `try_lift_successful_return`, `try_lift`, `try_lift`, `try_lift`, `try_lift`, `try_read`, `try_read`, `try_read`, `try_read`, `write`, `write`, `write`, `write`

class AuthInfo {
  final String endpoint;
  final String userId;
  final String avatar;
  final String name;
  final String token;
  final bool isStaff;
  final bool isCrossDomain;
  final Map<String, String>? privateExtra;

  const AuthInfo({
    required this.endpoint,
    required this.userId,
    required this.avatar,
    required this.name,
    required this.token,
    required this.isStaff,
    required this.isCrossDomain,
    this.privateExtra,
  });

  static Future<AuthInfo> default_() =>
      RustLib.instance.api.restsendSdkModelsUserAuthInfoDefault();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<AuthInfo> newInstance(
          {required String endpoint,
          required String userId,
          required String token}) =>
      RustLib.instance.api.restsendSdkModelsUserAuthInfoNew(
          endpoint: endpoint, userId: userId, token: token);

  @override
  int get hashCode =>
      endpoint.hashCode ^
      userId.hashCode ^
      avatar.hashCode ^
      name.hashCode ^
      token.hashCode ^
      isStaff.hashCode ^
      isCrossDomain.hashCode ^
      privateExtra.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AuthInfo &&
          runtimeType == other.runtimeType &&
          endpoint == other.endpoint &&
          userId == other.userId &&
          avatar == other.avatar &&
          name == other.name &&
          token == other.token &&
          isStaff == other.isStaff &&
          isCrossDomain == other.isCrossDomain &&
          privateExtra == other.privateExtra;
}

class User {
  final String userId;
  final String name;
  final String avatar;
  final String publicKey;
  final String remark;
  final bool isContact;
  final bool isStar;
  final bool isBlocked;
  final String locale;
  final String city;
  final String country;
  final String source;
  final String createdAt;
  final String gender;
  final String memo;
  final Map<String, String>? extra;
  final bool isStaff;
  final PlatformInt64 cachedAt;
  final bool isPartial;

  const User({
    required this.userId,
    required this.name,
    required this.avatar,
    required this.publicKey,
    required this.remark,
    required this.isContact,
    required this.isStar,
    required this.isBlocked,
    required this.locale,
    required this.city,
    required this.country,
    required this.source,
    required this.createdAt,
    required this.gender,
    required this.memo,
    this.extra,
    required this.isStaff,
    required this.cachedAt,
    required this.isPartial,
  });

  static Future<User> default_() =>
      RustLib.instance.api.restsendSdkModelsUserUserDefault();

  Future<User> merge({required User user}) => RustLib.instance.api
      .restsendSdkModelsUserUserMerge(that: this, user: user);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<User> newInstance({required String userId}) =>
      RustLib.instance.api.restsendSdkModelsUserUserNew(userId: userId);

  Future<PlatformInt64> sortKey() =>
      RustLib.instance.api.restsendSdkModelsUserUserSortKey(
        that: this,
      );

  @override
  int get hashCode =>
      userId.hashCode ^
      name.hashCode ^
      avatar.hashCode ^
      publicKey.hashCode ^
      remark.hashCode ^
      isContact.hashCode ^
      isStar.hashCode ^
      isBlocked.hashCode ^
      locale.hashCode ^
      city.hashCode ^
      country.hashCode ^
      source.hashCode ^
      createdAt.hashCode ^
      gender.hashCode ^
      memo.hashCode ^
      extra.hashCode ^
      isStaff.hashCode ^
      cachedAt.hashCode ^
      isPartial.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is User &&
          runtimeType == other.runtimeType &&
          userId == other.userId &&
          name == other.name &&
          avatar == other.avatar &&
          publicKey == other.publicKey &&
          remark == other.remark &&
          isContact == other.isContact &&
          isStar == other.isStar &&
          isBlocked == other.isBlocked &&
          locale == other.locale &&
          city == other.city &&
          country == other.country &&
          source == other.source &&
          createdAt == other.createdAt &&
          gender == other.gender &&
          memo == other.memo &&
          extra == other.extra &&
          isStaff == other.isStaff &&
          cachedAt == other.cachedAt &&
          isPartial == other.isPartial;
}

class UserProfile {
  final String avatar;
  final String gender;
  final String city;
  final String region;
  final String country;
  final Map<String, String>? privateExtra;

  const UserProfile({
    required this.avatar,
    required this.gender,
    required this.city,
    required this.region,
    required this.country,
    this.privateExtra,
  });

  static Future<UserProfile> default_() =>
      RustLib.instance.api.restsendSdkModelsUserUserProfileDefault();

  @override
  int get hashCode =>
      avatar.hashCode ^
      gender.hashCode ^
      city.hashCode ^
      region.hashCode ^
      country.hashCode ^
      privateExtra.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UserProfile &&
          runtimeType == other.runtimeType &&
          avatar == other.avatar &&
          gender == other.gender &&
          city == other.city &&
          region == other.region &&
          country == other.country &&
          privateExtra == other.privateExtra;
}
