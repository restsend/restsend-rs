// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import 'chat_log.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`, `from_str`, `from`, `from`, `lower_return`, `lower_return`, `lower`, `lower`, `lower`, `lower`, `to_string`, `try_convert_unexpected_callback_error`, `try_convert_unexpected_callback_error`, `try_lift_successful_return`, `try_lift_successful_return`, `try_lift`, `try_lift`, `try_lift`, `try_lift`, `try_read`, `try_read`, `try_read`, `try_read`, `write`, `write`, `write`, `write`

class Conversation {
  final String ownerId;
  final String topicId;
  final String updatedAt;
  final PlatformInt64 startSeq;
  final PlatformInt64 lastSeq;
  final PlatformInt64 lastReadSeq;
  final String? lastReadAt;
  final bool multiple;
  final String attendee;
  final PlatformInt64 members;
  final String name;
  final String icon;
  final bool sticky;
  final bool mute;
  final String source;
  final PlatformInt64 unread;
  final String lastSenderId;
  final Content? lastMessage;
  final String lastMessageAt;
  final PlatformInt64? lastMessageSeq;
  final String? remark;
  final Map<String, String>? extra;
  final Map<String, String>? topicExtra;
  final String? topicOwnerId;
  final List<Tag>? tags;
  final PlatformInt64 cachedAt;
  final bool isPartial;

  const Conversation({
    required this.ownerId,
    required this.topicId,
    required this.updatedAt,
    required this.startSeq,
    required this.lastSeq,
    required this.lastReadSeq,
    this.lastReadAt,
    required this.multiple,
    required this.attendee,
    required this.members,
    required this.name,
    required this.icon,
    required this.sticky,
    required this.mute,
    required this.source,
    required this.unread,
    required this.lastSenderId,
    this.lastMessage,
    required this.lastMessageAt,
    this.lastMessageSeq,
    this.remark,
    this.extra,
    this.topicExtra,
    this.topicOwnerId,
    this.tags,
    required this.cachedAt,
    required this.isPartial,
  });

  static Future<Conversation> default_() =>
      RustLib.instance.api.restsendSdkModelsConversationConversationDefault();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<Conversation> newInstance({required String topicId}) =>
      RustLib.instance.api
          .restsendSdkModelsConversationConversationNew(topicId: topicId);

  Future<PlatformInt64> sortKey() =>
      RustLib.instance.api.restsendSdkModelsConversationConversationSortKey(
        that: this,
      );

  @override
  int get hashCode =>
      ownerId.hashCode ^
      topicId.hashCode ^
      updatedAt.hashCode ^
      startSeq.hashCode ^
      lastSeq.hashCode ^
      lastReadSeq.hashCode ^
      lastReadAt.hashCode ^
      multiple.hashCode ^
      attendee.hashCode ^
      members.hashCode ^
      name.hashCode ^
      icon.hashCode ^
      sticky.hashCode ^
      mute.hashCode ^
      source.hashCode ^
      unread.hashCode ^
      lastSenderId.hashCode ^
      lastMessage.hashCode ^
      lastMessageAt.hashCode ^
      lastMessageSeq.hashCode ^
      remark.hashCode ^
      extra.hashCode ^
      topicExtra.hashCode ^
      topicOwnerId.hashCode ^
      tags.hashCode ^
      cachedAt.hashCode ^
      isPartial.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Conversation &&
          runtimeType == other.runtimeType &&
          ownerId == other.ownerId &&
          topicId == other.topicId &&
          updatedAt == other.updatedAt &&
          startSeq == other.startSeq &&
          lastSeq == other.lastSeq &&
          lastReadSeq == other.lastReadSeq &&
          lastReadAt == other.lastReadAt &&
          multiple == other.multiple &&
          attendee == other.attendee &&
          members == other.members &&
          name == other.name &&
          icon == other.icon &&
          sticky == other.sticky &&
          mute == other.mute &&
          source == other.source &&
          unread == other.unread &&
          lastSenderId == other.lastSenderId &&
          lastMessage == other.lastMessage &&
          lastMessageAt == other.lastMessageAt &&
          lastMessageSeq == other.lastMessageSeq &&
          remark == other.remark &&
          extra == other.extra &&
          topicExtra == other.topicExtra &&
          topicOwnerId == other.topicOwnerId &&
          tags == other.tags &&
          cachedAt == other.cachedAt &&
          isPartial == other.isPartial;
}

class ConversationUpdateFields {
  final bool? sticky;
  final bool? mute;
  final String? remark;
  final Map<String, String>? extra;
  final List<Tag>? tags;

  const ConversationUpdateFields({
    this.sticky,
    this.mute,
    this.remark,
    this.extra,
    this.tags,
  });

  static Future<ConversationUpdateFields> default_() => RustLib.instance.api
      .restsendSdkModelsConversationConversationUpdateFieldsDefault();

  @override
  int get hashCode =>
      sticky.hashCode ^
      mute.hashCode ^
      remark.hashCode ^
      extra.hashCode ^
      tags.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConversationUpdateFields &&
          runtimeType == other.runtimeType &&
          sticky == other.sticky &&
          mute == other.mute &&
          remark == other.remark &&
          extra == other.extra &&
          tags == other.tags;
}

class Tag {
  final String id;
  final String tagType;
  final String label;

  const Tag({
    required this.id,
    required this.tagType,
    required this.label,
  });

  static Future<Tag> default_() =>
      RustLib.instance.api.restsendSdkModelsConversationTagDefault();

  @override
  int get hashCode => id.hashCode ^ tagType.hashCode ^ label.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Tag &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          tagType == other.tagType &&
          label == other.label;
}
