// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(restsend_sdkFFI)
import restsend_sdkFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_restsend_sdk_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_restsend_sdk_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureRestsendSdkInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}




public protocol ClientProtocol: AnyObject {
    
    func acceptTopicJoin(topicId: String, userId: String, memo: String?) async throws 
    
    func addTopicAdmin(topicId: String, userId: String) async throws 
    
    func addTopicMember(topicId: String, userId: String) async throws  -> TopicMember
    
    func appActive() 
    
    func batchSyncChatlogs(conversations: [String: Conversation], limit: UInt32?) async throws 
    
    func cancelSend(chatId: String) 
    
    func cleanMessages(topicId: String) async throws 
    
    func clearConversation(topicId: String) async throws 
    
    func connect() async 
    
    func connectionStatus()  -> String
    
    func createChat(userId: String) async throws  -> Conversation
    
    func createTopic(members: [String], icon: String?, name: String?) async throws  -> Conversation
    
    func declineTopicJoin(topicId: String, userId: String, message: String?) async throws 
    
    func dismissTopic(topicId: String) async throws 
    
    func doRead(topicId: String) async throws 
    
    func doRecall(topicId: String, chatId: String, callback: MessageCallback?) async throws  -> String
    
    func doSend(topicId: String, content: Content, callback: MessageCallback?) async throws  -> String
    
    func doSendFile(topicId: String, attachment: Attachment, mentions: [String]?, mentionAll: Bool, replyId: String?, callback: MessageCallback?) async throws  -> String
    
    func doSendImage(topicId: String, attachment: Attachment, mentions: [String]?, replyId: String?, callback: MessageCallback?) async throws  -> String
    
    func doSendInvite(topicId: String, messsage: String?, callback: MessageCallback?) async throws  -> String
    
    func doSendLink(topicId: String, url: String, placeholder: String, mentions: [String]?, mentionAll: Bool, replyId: String?, callback: MessageCallback?) async throws  -> String
    
    func doSendLocation(topicId: String, latitude: String, longitude: String, address: String, mentions: [String]?, mentionAll: Bool, replyId: String?, callback: MessageCallback?) async throws  -> String
    
    func doSendLogs(topicId: String, sourceTopicId: String, logIds: [String], mentions: [String]?, mentionAll: Bool, callback: MessageCallback?) async throws  -> String
    
    func doSendText(topicId: String, text: String, mentions: [String]?, replyId: String?, callback: MessageCallback?) async throws  -> String
    
    func doSendVideo(topicId: String, attachment: Attachment, duration: String, mentions: [String]?, mentionAll: Bool, replyId: String?, callback: MessageCallback?) async throws  -> String
    
    func doSendVoice(topicId: String, attachment: Attachment, duration: String, mentions: [String]?, mentionAll: Bool, replyId: String?, callback: MessageCallback?) async throws  -> String
    
    func doTyping(topicId: String) async throws 
    
    func doUpdateExtra(topicId: String, chatId: String, extra: [String: String]?, callback: MessageCallback?) async throws  -> String
    
    func downloadFile(fileUrl: String, callback: DownloadCallback) async throws  -> String
    
    func fetchChatLogsDesc(topicId: String, lastSeq: Int64?, limit: UInt32) async throws  -> GetChatLogsResult
    
    func getChatLog(topicId: String, chatId: String) async  -> ChatLog?
    
    func getConversation(topicId: String, blocking: Bool) async  -> Conversation?
    
    func getTopic(topicId: String) async throws  -> Topic
    
    func getTopicAdmins(topicId: String) async  -> [User]?
    
    func getTopicKnocks(topicId: String) async  -> [TopicKnock]?
    
    func getTopicMembers(topicId: String, updatedAt: String, limit: UInt32) async throws  -> ListUserResult
    
    func getTopicOwner(topicId: String) async  -> User?
    
    func getUnreadCount() async  -> UInt32
    
    func getUser(userId: String, blocking: Bool) async  -> User?
    
    func getUsers(userIds: [String]) async  -> [User]
    
    func joinTopic(topicId: String, message: String?, source: String?) async throws 
    
    func quitTopic(topicId: String) async throws 
    
    func removeConversation(topicId: String) async 
    
    func removeMessages(topicId: String, chatIds: [String], syncToServer: Bool) async throws 
    
    func removeTopicAdmin(topicId: String, userId: String) async throws 
    
    func removeTopicMember(topicId: String, userId: String) async throws 
    
    func saveChatLogs(logs: [ChatLog]) async throws 
    
    func searchChatLog(topicId: String?, senderId: String?, keyword: String) async  -> GetChatLogsResult?
    
    func sendChatRequest(topicId: String, req: ChatRequest) async throws  -> ApiSendResponse
    
    func sendChatRequestViaConnection(req: ChatRequest, callback: MessageCallback?) async throws  -> String
    
    func setAllConversationsRead() async 
    
    func setAllowGuestChat(allow: Bool) async throws 
    
    func setCallback(callback: RsCallback?) 
    
    func setConversationExtra(topicId: String, extra: [String: String]?) async throws  -> Conversation
    
    func setConversationMute(topicId: String, mute: Bool) async throws  -> Conversation
    
    func setConversationRead(topicId: String, heavy: Bool) async 
    
    func setConversationRemark(topicId: String, remark: String?) async throws  -> Conversation
    
    func setConversationSticky(topicId: String, sticky: Bool) async throws  -> Conversation
    
    func setConversationTags(topicId: String, tags: [Tag]?) async throws  -> Conversation
    
    func setCountableCallback(callback: CountableCallback?) 
    
    func setKeepaliveIntervalSecs(secs: UInt32) 
    
    func setUserBlock(userId: String, block: Bool) async throws 
    
    func setUserRemark(userId: String, remark: String) async throws 
    
    func setUserStar(userId: String, star: Bool) async throws 
    
    func shutdown() async 
    
    func silentTopic(topicId: String, duration: String?) async throws 
    
    func silentTopicMember(topicId: String, userId: String, duration: String?) async throws 
    
    func syncChatLogs(topicId: String, lastSeq: Int64?, limit: UInt32, callback: SyncChatLogsCallback, ensureConversationLastVersion: Bool?) async 
    
    func syncConversations(updatedAt: String?, limit: UInt32, syncLogs: Bool, syncLogsLimit: UInt32?, syncLogsMaxCount: UInt32?, lastRemovedAt: String?, callback: SyncConversationsCallback) async 
    
    func transferTopic(topicId: String, userId: String) async throws 
    
    func trySyncChatLogs(conversation: Conversation, limit: UInt32?) async  -> Conversation?
    
    func updateTopic(topicId: String, name: String?, icon: String?) async throws 
    
    func updateTopicNotice(topicId: String, text: String) async throws 
    
}
open class Client: ClientProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_restsend_sdk_fn_clone_client(self.pointer, $0) }
    }
public convenience init(rootPath: String, dbName: String, info: AuthInfo) {
    let pointer =
        try! rustCall() {
    uniffi_restsend_sdk_fn_constructor_client_new(
        FfiConverterString.lower(rootPath),
        FfiConverterString.lower(dbName),
        FfiConverterTypeAuthInfo_lower(info),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_restsend_sdk_fn_free_client(pointer, $0) }
    }

    

    
open func acceptTopicJoin(topicId: String, userId: String, memo: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_accept_topic_join(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterString.lower(userId),FfiConverterOptionString.lower(memo)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func addTopicAdmin(topicId: String, userId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_add_topic_admin(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func addTopicMember(topicId: String, userId: String)async throws  -> TopicMember  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_add_topic_member(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTopicMember_lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func appActive()  {try! rustCall() {
    uniffi_restsend_sdk_fn_method_client_app_active(self.uniffiClonePointer(),$0
    )
}
}
    
open func batchSyncChatlogs(conversations: [String: Conversation], limit: UInt32?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_batch_sync_chatlogs(
                    self.uniffiClonePointer(),
                    FfiConverterDictionaryStringTypeConversation.lower(conversations),FfiConverterOptionUInt32.lower(limit)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func cancelSend(chatId: String)  {try! rustCall() {
    uniffi_restsend_sdk_fn_method_client_cancel_send(self.uniffiClonePointer(),
        FfiConverterString.lower(chatId),$0
    )
}
}
    
open func cleanMessages(topicId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_clean_messages(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func clearConversation(topicId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_clear_conversation(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func connect()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_connect(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func connectionStatus() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_restsend_sdk_fn_method_client_connection_status(self.uniffiClonePointer(),$0
    )
})
}
    
open func createChat(userId: String)async throws  -> Conversation  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_create_chat(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeConversation_lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func createTopic(members: [String], icon: String?, name: String?)async throws  -> Conversation  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_create_topic(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(members),FfiConverterOptionString.lower(icon),FfiConverterOptionString.lower(name)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeConversation_lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func declineTopicJoin(topicId: String, userId: String, message: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_decline_topic_join(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterString.lower(userId),FfiConverterOptionString.lower(message)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func dismissTopic(topicId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_dismiss_topic(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func doRead(topicId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_read(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func doRecall(topicId: String, chatId: String, callback: MessageCallback?)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_recall(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterString.lower(chatId),FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func doSend(topicId: String, content: Content, callback: MessageCallback?)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_send(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterTypeContent_lower(content),FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func doSendFile(topicId: String, attachment: Attachment, mentions: [String]?, mentionAll: Bool, replyId: String?, callback: MessageCallback?)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_send_file(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterTypeAttachment_lower(attachment),FfiConverterOptionSequenceString.lower(mentions),FfiConverterBool.lower(mentionAll),FfiConverterOptionString.lower(replyId),FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func doSendImage(topicId: String, attachment: Attachment, mentions: [String]?, replyId: String?, callback: MessageCallback?)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_send_image(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterTypeAttachment_lower(attachment),FfiConverterOptionSequenceString.lower(mentions),FfiConverterOptionString.lower(replyId),FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func doSendInvite(topicId: String, messsage: String?, callback: MessageCallback?)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_send_invite(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterOptionString.lower(messsage),FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func doSendLink(topicId: String, url: String, placeholder: String, mentions: [String]?, mentionAll: Bool, replyId: String?, callback: MessageCallback?)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_send_link(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterString.lower(url),FfiConverterString.lower(placeholder),FfiConverterOptionSequenceString.lower(mentions),FfiConverterBool.lower(mentionAll),FfiConverterOptionString.lower(replyId),FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func doSendLocation(topicId: String, latitude: String, longitude: String, address: String, mentions: [String]?, mentionAll: Bool, replyId: String?, callback: MessageCallback?)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_send_location(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterString.lower(latitude),FfiConverterString.lower(longitude),FfiConverterString.lower(address),FfiConverterOptionSequenceString.lower(mentions),FfiConverterBool.lower(mentionAll),FfiConverterOptionString.lower(replyId),FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func doSendLogs(topicId: String, sourceTopicId: String, logIds: [String], mentions: [String]?, mentionAll: Bool, callback: MessageCallback?)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_send_logs(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterString.lower(sourceTopicId),FfiConverterSequenceString.lower(logIds),FfiConverterOptionSequenceString.lower(mentions),FfiConverterBool.lower(mentionAll),FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func doSendText(topicId: String, text: String, mentions: [String]?, replyId: String?, callback: MessageCallback?)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_send_text(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterString.lower(text),FfiConverterOptionSequenceString.lower(mentions),FfiConverterOptionString.lower(replyId),FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func doSendVideo(topicId: String, attachment: Attachment, duration: String, mentions: [String]?, mentionAll: Bool, replyId: String?, callback: MessageCallback?)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_send_video(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterTypeAttachment_lower(attachment),FfiConverterString.lower(duration),FfiConverterOptionSequenceString.lower(mentions),FfiConverterBool.lower(mentionAll),FfiConverterOptionString.lower(replyId),FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func doSendVoice(topicId: String, attachment: Attachment, duration: String, mentions: [String]?, mentionAll: Bool, replyId: String?, callback: MessageCallback?)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_send_voice(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterTypeAttachment_lower(attachment),FfiConverterString.lower(duration),FfiConverterOptionSequenceString.lower(mentions),FfiConverterBool.lower(mentionAll),FfiConverterOptionString.lower(replyId),FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func doTyping(topicId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_typing(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func doUpdateExtra(topicId: String, chatId: String, extra: [String: String]?, callback: MessageCallback?)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_update_extra(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterString.lower(chatId),FfiConverterOptionDictionaryStringString.lower(extra),FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func downloadFile(fileUrl: String, callback: DownloadCallback)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_download_file(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(fileUrl),FfiConverterCallbackInterfaceDownloadCallback_lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func fetchChatLogsDesc(topicId: String, lastSeq: Int64?, limit: UInt32)async throws  -> GetChatLogsResult  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_fetch_chat_logs_desc(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterOptionInt64.lower(lastSeq),FfiConverterUInt32.lower(limit)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeGetChatLogsResult_lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func getChatLog(topicId: String, chatId: String)async  -> ChatLog?  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_get_chat_log(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterString.lower(chatId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeChatLog.lift,
            errorHandler: nil
            
        )
}
    
open func getConversation(topicId: String, blocking: Bool)async  -> Conversation?  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_get_conversation(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterBool.lower(blocking)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeConversation.lift,
            errorHandler: nil
            
        )
}
    
open func getTopic(topicId: String)async throws  -> Topic  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_get_topic(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTopic_lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func getTopicAdmins(topicId: String)async  -> [User]?  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_get_topic_admins(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionSequenceTypeUser.lift,
            errorHandler: nil
            
        )
}
    
open func getTopicKnocks(topicId: String)async  -> [TopicKnock]?  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_get_topic_knocks(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionSequenceTypeTopicKnock.lift,
            errorHandler: nil
            
        )
}
    
open func getTopicMembers(topicId: String, updatedAt: String, limit: UInt32)async throws  -> ListUserResult  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_get_topic_members(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterString.lower(updatedAt),FfiConverterUInt32.lower(limit)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeListUserResult_lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func getTopicOwner(topicId: String)async  -> User?  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_get_topic_owner(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeUser.lift,
            errorHandler: nil
            
        )
}
    
open func getUnreadCount()async  -> UInt32  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_get_unread_count(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_u32,
            completeFunc: ffi_restsend_sdk_rust_future_complete_u32,
            freeFunc: ffi_restsend_sdk_rust_future_free_u32,
            liftFunc: FfiConverterUInt32.lift,
            errorHandler: nil
            
        )
}
    
open func getUser(userId: String, blocking: Bool)async  -> User?  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_get_user(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId),FfiConverterBool.lower(blocking)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeUser.lift,
            errorHandler: nil
            
        )
}
    
open func getUsers(userIds: [String])async  -> [User]  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_get_users(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(userIds)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeUser.lift,
            errorHandler: nil
            
        )
}
    
open func joinTopic(topicId: String, message: String?, source: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_join_topic(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterOptionString.lower(message),FfiConverterOptionString.lower(source)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func quitTopic(topicId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_quit_topic(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func removeConversation(topicId: String)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_remove_conversation(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func removeMessages(topicId: String, chatIds: [String], syncToServer: Bool)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_remove_messages(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterSequenceString.lower(chatIds),FfiConverterBool.lower(syncToServer)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func removeTopicAdmin(topicId: String, userId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_remove_topic_admin(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func removeTopicMember(topicId: String, userId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_remove_topic_member(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func saveChatLogs(logs: [ChatLog])async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_save_chat_logs(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeChatLog.lower(logs)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func searchChatLog(topicId: String?, senderId: String?, keyword: String)async  -> GetChatLogsResult?  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_search_chat_log(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(topicId),FfiConverterOptionString.lower(senderId),FfiConverterString.lower(keyword)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeGetChatLogsResult.lift,
            errorHandler: nil
            
        )
}
    
open func sendChatRequest(topicId: String, req: ChatRequest)async throws  -> ApiSendResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_send_chat_request(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterTypeChatRequest_lower(req)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeAPISendResponse_lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func sendChatRequestViaConnection(req: ChatRequest, callback: MessageCallback?)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_send_chat_request_via_connection(
                    self.uniffiClonePointer(),
                    FfiConverterTypeChatRequest_lower(req),FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func setAllConversationsRead()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_set_all_conversations_read(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func setAllowGuestChat(allow: Bool)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_set_allow_guest_chat(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(allow)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func setCallback(callback: RsCallback?)  {try! rustCall() {
    uniffi_restsend_sdk_fn_method_client_set_callback(self.uniffiClonePointer(),
        FfiConverterOptionCallbackInterfaceRsCallback.lower(callback),$0
    )
}
}
    
open func setConversationExtra(topicId: String, extra: [String: String]?)async throws  -> Conversation  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_set_conversation_extra(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterOptionDictionaryStringString.lower(extra)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeConversation_lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func setConversationMute(topicId: String, mute: Bool)async throws  -> Conversation  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_set_conversation_mute(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterBool.lower(mute)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeConversation_lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func setConversationRead(topicId: String, heavy: Bool)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_set_conversation_read(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterBool.lower(heavy)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func setConversationRemark(topicId: String, remark: String?)async throws  -> Conversation  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_set_conversation_remark(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterOptionString.lower(remark)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeConversation_lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func setConversationSticky(topicId: String, sticky: Bool)async throws  -> Conversation  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_set_conversation_sticky(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterBool.lower(sticky)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeConversation_lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func setConversationTags(topicId: String, tags: [Tag]?)async throws  -> Conversation  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_set_conversation_tags(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterOptionSequenceTypeTag.lower(tags)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeConversation_lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func setCountableCallback(callback: CountableCallback?)  {try! rustCall() {
    uniffi_restsend_sdk_fn_method_client_set_countable_callback(self.uniffiClonePointer(),
        FfiConverterOptionCallbackInterfaceCountableCallback.lower(callback),$0
    )
}
}
    
open func setKeepaliveIntervalSecs(secs: UInt32)  {try! rustCall() {
    uniffi_restsend_sdk_fn_method_client_set_keepalive_interval_secs(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(secs),$0
    )
}
}
    
open func setUserBlock(userId: String, block: Bool)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_set_user_block(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId),FfiConverterBool.lower(block)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func setUserRemark(userId: String, remark: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_set_user_remark(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId),FfiConverterString.lower(remark)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func setUserStar(userId: String, star: Bool)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_set_user_star(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId),FfiConverterBool.lower(star)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func shutdown()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_shutdown(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func silentTopic(topicId: String, duration: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_silent_topic(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterOptionString.lower(duration)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func silentTopicMember(topicId: String, userId: String, duration: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_silent_topic_member(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterString.lower(userId),FfiConverterOptionString.lower(duration)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func syncChatLogs(topicId: String, lastSeq: Int64?, limit: UInt32, callback: SyncChatLogsCallback, ensureConversationLastVersion: Bool?)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_sync_chat_logs(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterOptionInt64.lower(lastSeq),FfiConverterUInt32.lower(limit),FfiConverterCallbackInterfaceSyncChatLogsCallback_lower(callback),FfiConverterOptionBool.lower(ensureConversationLastVersion)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func syncConversations(updatedAt: String?, limit: UInt32, syncLogs: Bool, syncLogsLimit: UInt32?, syncLogsMaxCount: UInt32?, lastRemovedAt: String?, callback: SyncConversationsCallback)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_sync_conversations(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(updatedAt),FfiConverterUInt32.lower(limit),FfiConverterBool.lower(syncLogs),FfiConverterOptionUInt32.lower(syncLogsLimit),FfiConverterOptionUInt32.lower(syncLogsMaxCount),FfiConverterOptionString.lower(lastRemovedAt),FfiConverterCallbackInterfaceSyncConversationsCallback_lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func transferTopic(topicId: String, userId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_transfer_topic(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func trySyncChatLogs(conversation: Conversation, limit: UInt32?)async  -> Conversation?  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_try_sync_chat_logs(
                    self.uniffiClonePointer(),
                    FfiConverterTypeConversation_lower(conversation),FfiConverterOptionUInt32.lower(limit)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeConversation.lift,
            errorHandler: nil
            
        )
}
    
open func updateTopic(topicId: String, name: String?, icon: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_update_topic(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterOptionString.lower(name),FfiConverterOptionString.lower(icon)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func updateTopicNotice(topicId: String, text: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_update_topic_notice(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topicId),FfiConverterString.lower(text)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Client

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
        return Client(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Client) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Client {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Client, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
    return try FfiConverterTypeClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClient_lower(_ value: Client) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClient.lower(value)
}




public struct ApiSendResponse {
    public var senderId: String
    public var topicId: String
    public var attendeeId: String
    public var chatId: String
    public var code: UInt16
    public var seq: Int64
    public var message: String
    public var usage: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(senderId: String, topicId: String, attendeeId: String, chatId: String, code: UInt16, seq: Int64, message: String, usage: Int64) {
        self.senderId = senderId
        self.topicId = topicId
        self.attendeeId = attendeeId
        self.chatId = chatId
        self.code = code
        self.seq = seq
        self.message = message
        self.usage = usage
    }
}

#if compiler(>=6)
extension ApiSendResponse: Sendable {}
#endif


extension ApiSendResponse: Equatable, Hashable {
    public static func ==(lhs: ApiSendResponse, rhs: ApiSendResponse) -> Bool {
        if lhs.senderId != rhs.senderId {
            return false
        }
        if lhs.topicId != rhs.topicId {
            return false
        }
        if lhs.attendeeId != rhs.attendeeId {
            return false
        }
        if lhs.chatId != rhs.chatId {
            return false
        }
        if lhs.code != rhs.code {
            return false
        }
        if lhs.seq != rhs.seq {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.usage != rhs.usage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(senderId)
        hasher.combine(topicId)
        hasher.combine(attendeeId)
        hasher.combine(chatId)
        hasher.combine(code)
        hasher.combine(seq)
        hasher.combine(message)
        hasher.combine(usage)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAPISendResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApiSendResponse {
        return
            try ApiSendResponse(
                senderId: FfiConverterString.read(from: &buf), 
                topicId: FfiConverterString.read(from: &buf), 
                attendeeId: FfiConverterString.read(from: &buf), 
                chatId: FfiConverterString.read(from: &buf), 
                code: FfiConverterUInt16.read(from: &buf), 
                seq: FfiConverterInt64.read(from: &buf), 
                message: FfiConverterString.read(from: &buf), 
                usage: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ApiSendResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.senderId, into: &buf)
        FfiConverterString.write(value.topicId, into: &buf)
        FfiConverterString.write(value.attendeeId, into: &buf)
        FfiConverterString.write(value.chatId, into: &buf)
        FfiConverterUInt16.write(value.code, into: &buf)
        FfiConverterInt64.write(value.seq, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
        FfiConverterInt64.write(value.usage, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAPISendResponse_lift(_ buf: RustBuffer) throws -> ApiSendResponse {
    return try FfiConverterTypeAPISendResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAPISendResponse_lower(_ value: ApiSendResponse) -> RustBuffer {
    return FfiConverterTypeAPISendResponse.lower(value)
}


public struct Attachment {
    /**
     * if url is not empty, it means the attachment is from remote, without upload
     */
    public var url: String
    public var size: Int64
    public var thumbnail: String
    public var fileName: String
    public var filePath: String
    public var urlOrData: String
    public var isPrivate: Bool
    public var status: AttachmentStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * if url is not empty, it means the attachment is from remote, without upload
         */url: String, size: Int64, thumbnail: String, fileName: String, filePath: String, urlOrData: String, isPrivate: Bool, status: AttachmentStatus) {
        self.url = url
        self.size = size
        self.thumbnail = thumbnail
        self.fileName = fileName
        self.filePath = filePath
        self.urlOrData = urlOrData
        self.isPrivate = isPrivate
        self.status = status
    }
}

#if compiler(>=6)
extension Attachment: Sendable {}
#endif


extension Attachment: Equatable, Hashable {
    public static func ==(lhs: Attachment, rhs: Attachment) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.size != rhs.size {
            return false
        }
        if lhs.thumbnail != rhs.thumbnail {
            return false
        }
        if lhs.fileName != rhs.fileName {
            return false
        }
        if lhs.filePath != rhs.filePath {
            return false
        }
        if lhs.urlOrData != rhs.urlOrData {
            return false
        }
        if lhs.isPrivate != rhs.isPrivate {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(size)
        hasher.combine(thumbnail)
        hasher.combine(fileName)
        hasher.combine(filePath)
        hasher.combine(urlOrData)
        hasher.combine(isPrivate)
        hasher.combine(status)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAttachment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Attachment {
        return
            try Attachment(
                url: FfiConverterString.read(from: &buf), 
                size: FfiConverterInt64.read(from: &buf), 
                thumbnail: FfiConverterString.read(from: &buf), 
                fileName: FfiConverterString.read(from: &buf), 
                filePath: FfiConverterString.read(from: &buf), 
                urlOrData: FfiConverterString.read(from: &buf), 
                isPrivate: FfiConverterBool.read(from: &buf), 
                status: FfiConverterTypeAttachmentStatus.read(from: &buf)
        )
    }

    public static func write(_ value: Attachment, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterInt64.write(value.size, into: &buf)
        FfiConverterString.write(value.thumbnail, into: &buf)
        FfiConverterString.write(value.fileName, into: &buf)
        FfiConverterString.write(value.filePath, into: &buf)
        FfiConverterString.write(value.urlOrData, into: &buf)
        FfiConverterBool.write(value.isPrivate, into: &buf)
        FfiConverterTypeAttachmentStatus.write(value.status, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttachment_lift(_ buf: RustBuffer) throws -> Attachment {
    return try FfiConverterTypeAttachment.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttachment_lower(_ value: Attachment) -> RustBuffer {
    return FfiConverterTypeAttachment.lower(value)
}


public struct AuthInfo {
    public var endpoint: String
    public var userId: String
    public var avatar: String
    public var name: String
    public var token: String
    public var isStaff: Bool
    public var isCrossDomain: Bool
    public var privateExtra: [String: String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(endpoint: String, userId: String, avatar: String, name: String, token: String, isStaff: Bool, isCrossDomain: Bool, privateExtra: [String: String]?) {
        self.endpoint = endpoint
        self.userId = userId
        self.avatar = avatar
        self.name = name
        self.token = token
        self.isStaff = isStaff
        self.isCrossDomain = isCrossDomain
        self.privateExtra = privateExtra
    }
}

#if compiler(>=6)
extension AuthInfo: Sendable {}
#endif


extension AuthInfo: Equatable, Hashable {
    public static func ==(lhs: AuthInfo, rhs: AuthInfo) -> Bool {
        if lhs.endpoint != rhs.endpoint {
            return false
        }
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.avatar != rhs.avatar {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.token != rhs.token {
            return false
        }
        if lhs.isStaff != rhs.isStaff {
            return false
        }
        if lhs.isCrossDomain != rhs.isCrossDomain {
            return false
        }
        if lhs.privateExtra != rhs.privateExtra {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(endpoint)
        hasher.combine(userId)
        hasher.combine(avatar)
        hasher.combine(name)
        hasher.combine(token)
        hasher.combine(isStaff)
        hasher.combine(isCrossDomain)
        hasher.combine(privateExtra)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthInfo {
        return
            try AuthInfo(
                endpoint: FfiConverterString.read(from: &buf), 
                userId: FfiConverterString.read(from: &buf), 
                avatar: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                token: FfiConverterString.read(from: &buf), 
                isStaff: FfiConverterBool.read(from: &buf), 
                isCrossDomain: FfiConverterBool.read(from: &buf), 
                privateExtra: FfiConverterOptionDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: AuthInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.endpoint, into: &buf)
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterString.write(value.avatar, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.token, into: &buf)
        FfiConverterBool.write(value.isStaff, into: &buf)
        FfiConverterBool.write(value.isCrossDomain, into: &buf)
        FfiConverterOptionDictionaryStringString.write(value.privateExtra, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthInfo_lift(_ buf: RustBuffer) throws -> AuthInfo {
    return try FfiConverterTypeAuthInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthInfo_lower(_ value: AuthInfo) -> RustBuffer {
    return FfiConverterTypeAuthInfo.lower(value)
}


public struct ChatLog {
    public var topicId: String
    public var id: String
    public var seq: Int64
    public var createdAt: String
    public var senderId: String
    public var content: Content
    public var read: Bool
    public var recall: Bool
    public var status: ChatLogStatus
    public var cachedAt: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(topicId: String, id: String, seq: Int64, createdAt: String, senderId: String, content: Content, read: Bool, recall: Bool, status: ChatLogStatus, cachedAt: Int64) {
        self.topicId = topicId
        self.id = id
        self.seq = seq
        self.createdAt = createdAt
        self.senderId = senderId
        self.content = content
        self.read = read
        self.recall = recall
        self.status = status
        self.cachedAt = cachedAt
    }
}

#if compiler(>=6)
extension ChatLog: Sendable {}
#endif


extension ChatLog: Equatable, Hashable {
    public static func ==(lhs: ChatLog, rhs: ChatLog) -> Bool {
        if lhs.topicId != rhs.topicId {
            return false
        }
        if lhs.id != rhs.id {
            return false
        }
        if lhs.seq != rhs.seq {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.senderId != rhs.senderId {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        if lhs.read != rhs.read {
            return false
        }
        if lhs.recall != rhs.recall {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.cachedAt != rhs.cachedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(topicId)
        hasher.combine(id)
        hasher.combine(seq)
        hasher.combine(createdAt)
        hasher.combine(senderId)
        hasher.combine(content)
        hasher.combine(read)
        hasher.combine(recall)
        hasher.combine(status)
        hasher.combine(cachedAt)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChatLog: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChatLog {
        return
            try ChatLog(
                topicId: FfiConverterString.read(from: &buf), 
                id: FfiConverterString.read(from: &buf), 
                seq: FfiConverterInt64.read(from: &buf), 
                createdAt: FfiConverterString.read(from: &buf), 
                senderId: FfiConverterString.read(from: &buf), 
                content: FfiConverterTypeContent.read(from: &buf), 
                read: FfiConverterBool.read(from: &buf), 
                recall: FfiConverterBool.read(from: &buf), 
                status: FfiConverterTypeChatLogStatus.read(from: &buf), 
                cachedAt: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ChatLog, into buf: inout [UInt8]) {
        FfiConverterString.write(value.topicId, into: &buf)
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterInt64.write(value.seq, into: &buf)
        FfiConverterString.write(value.createdAt, into: &buf)
        FfiConverterString.write(value.senderId, into: &buf)
        FfiConverterTypeContent.write(value.content, into: &buf)
        FfiConverterBool.write(value.read, into: &buf)
        FfiConverterBool.write(value.recall, into: &buf)
        FfiConverterTypeChatLogStatus.write(value.status, into: &buf)
        FfiConverterInt64.write(value.cachedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChatLog_lift(_ buf: RustBuffer) throws -> ChatLog {
    return try FfiConverterTypeChatLog.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChatLog_lower(_ value: ChatLog) -> RustBuffer {
    return FfiConverterTypeChatLog.lower(value)
}


public struct ChatRequest {
    public var reqType: String
    public var chatId: String
    public var code: UInt32
    public var topicId: String
    public var seq: Int64
    public var attendee: String
    public var attendeeProfile: User?
    public var createdAt: String
    public var content: Content?
    public var e2eContent: String?
    public var message: String?
    public var source: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(reqType: String, chatId: String, code: UInt32, topicId: String, seq: Int64, attendee: String, attendeeProfile: User?, createdAt: String, content: Content?, e2eContent: String?, message: String?, source: String?) {
        self.reqType = reqType
        self.chatId = chatId
        self.code = code
        self.topicId = topicId
        self.seq = seq
        self.attendee = attendee
        self.attendeeProfile = attendeeProfile
        self.createdAt = createdAt
        self.content = content
        self.e2eContent = e2eContent
        self.message = message
        self.source = source
    }
}

#if compiler(>=6)
extension ChatRequest: Sendable {}
#endif


extension ChatRequest: Equatable, Hashable {
    public static func ==(lhs: ChatRequest, rhs: ChatRequest) -> Bool {
        if lhs.reqType != rhs.reqType {
            return false
        }
        if lhs.chatId != rhs.chatId {
            return false
        }
        if lhs.code != rhs.code {
            return false
        }
        if lhs.topicId != rhs.topicId {
            return false
        }
        if lhs.seq != rhs.seq {
            return false
        }
        if lhs.attendee != rhs.attendee {
            return false
        }
        if lhs.attendeeProfile != rhs.attendeeProfile {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        if lhs.e2eContent != rhs.e2eContent {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(reqType)
        hasher.combine(chatId)
        hasher.combine(code)
        hasher.combine(topicId)
        hasher.combine(seq)
        hasher.combine(attendee)
        hasher.combine(attendeeProfile)
        hasher.combine(createdAt)
        hasher.combine(content)
        hasher.combine(e2eContent)
        hasher.combine(message)
        hasher.combine(source)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChatRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChatRequest {
        return
            try ChatRequest(
                reqType: FfiConverterString.read(from: &buf), 
                chatId: FfiConverterString.read(from: &buf), 
                code: FfiConverterUInt32.read(from: &buf), 
                topicId: FfiConverterString.read(from: &buf), 
                seq: FfiConverterInt64.read(from: &buf), 
                attendee: FfiConverterString.read(from: &buf), 
                attendeeProfile: FfiConverterOptionTypeUser.read(from: &buf), 
                createdAt: FfiConverterString.read(from: &buf), 
                content: FfiConverterOptionTypeContent.read(from: &buf), 
                e2eContent: FfiConverterOptionString.read(from: &buf), 
                message: FfiConverterOptionString.read(from: &buf), 
                source: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ChatRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.reqType, into: &buf)
        FfiConverterString.write(value.chatId, into: &buf)
        FfiConverterUInt32.write(value.code, into: &buf)
        FfiConverterString.write(value.topicId, into: &buf)
        FfiConverterInt64.write(value.seq, into: &buf)
        FfiConverterString.write(value.attendee, into: &buf)
        FfiConverterOptionTypeUser.write(value.attendeeProfile, into: &buf)
        FfiConverterString.write(value.createdAt, into: &buf)
        FfiConverterOptionTypeContent.write(value.content, into: &buf)
        FfiConverterOptionString.write(value.e2eContent, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
        FfiConverterOptionString.write(value.source, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChatRequest_lift(_ buf: RustBuffer) throws -> ChatRequest {
    return try FfiConverterTypeChatRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChatRequest_lower(_ value: ChatRequest) -> RustBuffer {
    return FfiConverterTypeChatRequest.lower(value)
}


public struct ChatRequestStatus {
    /**
     * The message is read by the user
     */
    public var hasRead: Bool
    /**
     * The message is not read count
     */
    public var unreadCountable: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The message is read by the user
         */hasRead: Bool, 
        /**
         * The message is not read count
         */unreadCountable: Bool) {
        self.hasRead = hasRead
        self.unreadCountable = unreadCountable
    }
}

#if compiler(>=6)
extension ChatRequestStatus: Sendable {}
#endif


extension ChatRequestStatus: Equatable, Hashable {
    public static func ==(lhs: ChatRequestStatus, rhs: ChatRequestStatus) -> Bool {
        if lhs.hasRead != rhs.hasRead {
            return false
        }
        if lhs.unreadCountable != rhs.unreadCountable {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(hasRead)
        hasher.combine(unreadCountable)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChatRequestStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChatRequestStatus {
        return
            try ChatRequestStatus(
                hasRead: FfiConverterBool.read(from: &buf), 
                unreadCountable: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: ChatRequestStatus, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.hasRead, into: &buf)
        FfiConverterBool.write(value.unreadCountable, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChatRequestStatus_lift(_ buf: RustBuffer) throws -> ChatRequestStatus {
    return try FfiConverterTypeChatRequestStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChatRequestStatus_lower(_ value: ChatRequestStatus) -> RustBuffer {
    return FfiConverterTypeChatRequestStatus.lower(value)
}


public struct Content {
    public var contentType: String
    public var encrypted: Bool
    public var checksum: UInt32
    public var text: String
    public var placeholder: String
    public var thumbnail: String
    public var duration: String
    public var size: UInt64
    public var width: Float
    public var height: Float
    public var mentions: [String]
    public var mentionAll: Bool
    public var reply: String
    public var replyContent: String?
    public var createdAt: String
    public var attachment: Attachment?
    public var extra: [String: String]?
    public var unreadable: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(contentType: String, encrypted: Bool, checksum: UInt32, text: String, placeholder: String, thumbnail: String, duration: String, size: UInt64, width: Float, height: Float, mentions: [String], mentionAll: Bool, reply: String, replyContent: String?, createdAt: String, attachment: Attachment?, extra: [String: String]?, unreadable: Bool) {
        self.contentType = contentType
        self.encrypted = encrypted
        self.checksum = checksum
        self.text = text
        self.placeholder = placeholder
        self.thumbnail = thumbnail
        self.duration = duration
        self.size = size
        self.width = width
        self.height = height
        self.mentions = mentions
        self.mentionAll = mentionAll
        self.reply = reply
        self.replyContent = replyContent
        self.createdAt = createdAt
        self.attachment = attachment
        self.extra = extra
        self.unreadable = unreadable
    }
}

#if compiler(>=6)
extension Content: Sendable {}
#endif


extension Content: Equatable, Hashable {
    public static func ==(lhs: Content, rhs: Content) -> Bool {
        if lhs.contentType != rhs.contentType {
            return false
        }
        if lhs.encrypted != rhs.encrypted {
            return false
        }
        if lhs.checksum != rhs.checksum {
            return false
        }
        if lhs.text != rhs.text {
            return false
        }
        if lhs.placeholder != rhs.placeholder {
            return false
        }
        if lhs.thumbnail != rhs.thumbnail {
            return false
        }
        if lhs.duration != rhs.duration {
            return false
        }
        if lhs.size != rhs.size {
            return false
        }
        if lhs.width != rhs.width {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        if lhs.mentions != rhs.mentions {
            return false
        }
        if lhs.mentionAll != rhs.mentionAll {
            return false
        }
        if lhs.reply != rhs.reply {
            return false
        }
        if lhs.replyContent != rhs.replyContent {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.attachment != rhs.attachment {
            return false
        }
        if lhs.extra != rhs.extra {
            return false
        }
        if lhs.unreadable != rhs.unreadable {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(contentType)
        hasher.combine(encrypted)
        hasher.combine(checksum)
        hasher.combine(text)
        hasher.combine(placeholder)
        hasher.combine(thumbnail)
        hasher.combine(duration)
        hasher.combine(size)
        hasher.combine(width)
        hasher.combine(height)
        hasher.combine(mentions)
        hasher.combine(mentionAll)
        hasher.combine(reply)
        hasher.combine(replyContent)
        hasher.combine(createdAt)
        hasher.combine(attachment)
        hasher.combine(extra)
        hasher.combine(unreadable)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Content {
        return
            try Content(
                contentType: FfiConverterString.read(from: &buf), 
                encrypted: FfiConverterBool.read(from: &buf), 
                checksum: FfiConverterUInt32.read(from: &buf), 
                text: FfiConverterString.read(from: &buf), 
                placeholder: FfiConverterString.read(from: &buf), 
                thumbnail: FfiConverterString.read(from: &buf), 
                duration: FfiConverterString.read(from: &buf), 
                size: FfiConverterUInt64.read(from: &buf), 
                width: FfiConverterFloat.read(from: &buf), 
                height: FfiConverterFloat.read(from: &buf), 
                mentions: FfiConverterSequenceString.read(from: &buf), 
                mentionAll: FfiConverterBool.read(from: &buf), 
                reply: FfiConverterString.read(from: &buf), 
                replyContent: FfiConverterOptionString.read(from: &buf), 
                createdAt: FfiConverterString.read(from: &buf), 
                attachment: FfiConverterOptionTypeAttachment.read(from: &buf), 
                extra: FfiConverterOptionDictionaryStringString.read(from: &buf), 
                unreadable: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Content, into buf: inout [UInt8]) {
        FfiConverterString.write(value.contentType, into: &buf)
        FfiConverterBool.write(value.encrypted, into: &buf)
        FfiConverterUInt32.write(value.checksum, into: &buf)
        FfiConverterString.write(value.text, into: &buf)
        FfiConverterString.write(value.placeholder, into: &buf)
        FfiConverterString.write(value.thumbnail, into: &buf)
        FfiConverterString.write(value.duration, into: &buf)
        FfiConverterUInt64.write(value.size, into: &buf)
        FfiConverterFloat.write(value.width, into: &buf)
        FfiConverterFloat.write(value.height, into: &buf)
        FfiConverterSequenceString.write(value.mentions, into: &buf)
        FfiConverterBool.write(value.mentionAll, into: &buf)
        FfiConverterString.write(value.reply, into: &buf)
        FfiConverterOptionString.write(value.replyContent, into: &buf)
        FfiConverterString.write(value.createdAt, into: &buf)
        FfiConverterOptionTypeAttachment.write(value.attachment, into: &buf)
        FfiConverterOptionDictionaryStringString.write(value.extra, into: &buf)
        FfiConverterBool.write(value.unreadable, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContent_lift(_ buf: RustBuffer) throws -> Content {
    return try FfiConverterTypeContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContent_lower(_ value: Content) -> RustBuffer {
    return FfiConverterTypeContent.lower(value)
}


public struct Conversation {
    public var ownerId: String
    public var topicId: String
    public var updatedAt: String
    public var startSeq: Int64
    public var lastSeq: Int64
    public var lastReadSeq: Int64
    public var lastReadAt: String?
    public var multiple: Bool
    public var attendee: String
    public var members: Int64
    public var name: String
    public var icon: String
    public var sticky: Bool
    public var mute: Bool
    public var source: String
    public var unread: Int64
    public var lastSenderId: String
    public var lastMessage: Content?
    public var lastMessageAt: String
    public var lastMessageSeq: Int64?
    public var remark: String?
    public var extra: [String: String]?
    public var topicExtra: [String: String]?
    public var topicOwnerId: String?
    public var topicCreatedAt: String?
    public var tags: [Tag]?
    public var cachedAt: Int64
    public var isPartial: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ownerId: String, topicId: String, updatedAt: String, startSeq: Int64, lastSeq: Int64, lastReadSeq: Int64, lastReadAt: String?, multiple: Bool, attendee: String, members: Int64, name: String, icon: String, sticky: Bool, mute: Bool, source: String, unread: Int64, lastSenderId: String, lastMessage: Content?, lastMessageAt: String, lastMessageSeq: Int64?, remark: String?, extra: [String: String]?, topicExtra: [String: String]?, topicOwnerId: String?, topicCreatedAt: String?, tags: [Tag]?, cachedAt: Int64, isPartial: Bool) {
        self.ownerId = ownerId
        self.topicId = topicId
        self.updatedAt = updatedAt
        self.startSeq = startSeq
        self.lastSeq = lastSeq
        self.lastReadSeq = lastReadSeq
        self.lastReadAt = lastReadAt
        self.multiple = multiple
        self.attendee = attendee
        self.members = members
        self.name = name
        self.icon = icon
        self.sticky = sticky
        self.mute = mute
        self.source = source
        self.unread = unread
        self.lastSenderId = lastSenderId
        self.lastMessage = lastMessage
        self.lastMessageAt = lastMessageAt
        self.lastMessageSeq = lastMessageSeq
        self.remark = remark
        self.extra = extra
        self.topicExtra = topicExtra
        self.topicOwnerId = topicOwnerId
        self.topicCreatedAt = topicCreatedAt
        self.tags = tags
        self.cachedAt = cachedAt
        self.isPartial = isPartial
    }
}

#if compiler(>=6)
extension Conversation: Sendable {}
#endif


extension Conversation: Equatable, Hashable {
    public static func ==(lhs: Conversation, rhs: Conversation) -> Bool {
        if lhs.ownerId != rhs.ownerId {
            return false
        }
        if lhs.topicId != rhs.topicId {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        if lhs.startSeq != rhs.startSeq {
            return false
        }
        if lhs.lastSeq != rhs.lastSeq {
            return false
        }
        if lhs.lastReadSeq != rhs.lastReadSeq {
            return false
        }
        if lhs.lastReadAt != rhs.lastReadAt {
            return false
        }
        if lhs.multiple != rhs.multiple {
            return false
        }
        if lhs.attendee != rhs.attendee {
            return false
        }
        if lhs.members != rhs.members {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.icon != rhs.icon {
            return false
        }
        if lhs.sticky != rhs.sticky {
            return false
        }
        if lhs.mute != rhs.mute {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        if lhs.unread != rhs.unread {
            return false
        }
        if lhs.lastSenderId != rhs.lastSenderId {
            return false
        }
        if lhs.lastMessage != rhs.lastMessage {
            return false
        }
        if lhs.lastMessageAt != rhs.lastMessageAt {
            return false
        }
        if lhs.lastMessageSeq != rhs.lastMessageSeq {
            return false
        }
        if lhs.remark != rhs.remark {
            return false
        }
        if lhs.extra != rhs.extra {
            return false
        }
        if lhs.topicExtra != rhs.topicExtra {
            return false
        }
        if lhs.topicOwnerId != rhs.topicOwnerId {
            return false
        }
        if lhs.topicCreatedAt != rhs.topicCreatedAt {
            return false
        }
        if lhs.tags != rhs.tags {
            return false
        }
        if lhs.cachedAt != rhs.cachedAt {
            return false
        }
        if lhs.isPartial != rhs.isPartial {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ownerId)
        hasher.combine(topicId)
        hasher.combine(updatedAt)
        hasher.combine(startSeq)
        hasher.combine(lastSeq)
        hasher.combine(lastReadSeq)
        hasher.combine(lastReadAt)
        hasher.combine(multiple)
        hasher.combine(attendee)
        hasher.combine(members)
        hasher.combine(name)
        hasher.combine(icon)
        hasher.combine(sticky)
        hasher.combine(mute)
        hasher.combine(source)
        hasher.combine(unread)
        hasher.combine(lastSenderId)
        hasher.combine(lastMessage)
        hasher.combine(lastMessageAt)
        hasher.combine(lastMessageSeq)
        hasher.combine(remark)
        hasher.combine(extra)
        hasher.combine(topicExtra)
        hasher.combine(topicOwnerId)
        hasher.combine(topicCreatedAt)
        hasher.combine(tags)
        hasher.combine(cachedAt)
        hasher.combine(isPartial)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConversation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Conversation {
        return
            try Conversation(
                ownerId: FfiConverterString.read(from: &buf), 
                topicId: FfiConverterString.read(from: &buf), 
                updatedAt: FfiConverterString.read(from: &buf), 
                startSeq: FfiConverterInt64.read(from: &buf), 
                lastSeq: FfiConverterInt64.read(from: &buf), 
                lastReadSeq: FfiConverterInt64.read(from: &buf), 
                lastReadAt: FfiConverterOptionString.read(from: &buf), 
                multiple: FfiConverterBool.read(from: &buf), 
                attendee: FfiConverterString.read(from: &buf), 
                members: FfiConverterInt64.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                icon: FfiConverterString.read(from: &buf), 
                sticky: FfiConverterBool.read(from: &buf), 
                mute: FfiConverterBool.read(from: &buf), 
                source: FfiConverterString.read(from: &buf), 
                unread: FfiConverterInt64.read(from: &buf), 
                lastSenderId: FfiConverterString.read(from: &buf), 
                lastMessage: FfiConverterOptionTypeContent.read(from: &buf), 
                lastMessageAt: FfiConverterString.read(from: &buf), 
                lastMessageSeq: FfiConverterOptionInt64.read(from: &buf), 
                remark: FfiConverterOptionString.read(from: &buf), 
                extra: FfiConverterOptionDictionaryStringString.read(from: &buf), 
                topicExtra: FfiConverterOptionDictionaryStringString.read(from: &buf), 
                topicOwnerId: FfiConverterOptionString.read(from: &buf), 
                topicCreatedAt: FfiConverterOptionString.read(from: &buf), 
                tags: FfiConverterOptionSequenceTypeTag.read(from: &buf), 
                cachedAt: FfiConverterInt64.read(from: &buf), 
                isPartial: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Conversation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.ownerId, into: &buf)
        FfiConverterString.write(value.topicId, into: &buf)
        FfiConverterString.write(value.updatedAt, into: &buf)
        FfiConverterInt64.write(value.startSeq, into: &buf)
        FfiConverterInt64.write(value.lastSeq, into: &buf)
        FfiConverterInt64.write(value.lastReadSeq, into: &buf)
        FfiConverterOptionString.write(value.lastReadAt, into: &buf)
        FfiConverterBool.write(value.multiple, into: &buf)
        FfiConverterString.write(value.attendee, into: &buf)
        FfiConverterInt64.write(value.members, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.icon, into: &buf)
        FfiConverterBool.write(value.sticky, into: &buf)
        FfiConverterBool.write(value.mute, into: &buf)
        FfiConverterString.write(value.source, into: &buf)
        FfiConverterInt64.write(value.unread, into: &buf)
        FfiConverterString.write(value.lastSenderId, into: &buf)
        FfiConverterOptionTypeContent.write(value.lastMessage, into: &buf)
        FfiConverterString.write(value.lastMessageAt, into: &buf)
        FfiConverterOptionInt64.write(value.lastMessageSeq, into: &buf)
        FfiConverterOptionString.write(value.remark, into: &buf)
        FfiConverterOptionDictionaryStringString.write(value.extra, into: &buf)
        FfiConverterOptionDictionaryStringString.write(value.topicExtra, into: &buf)
        FfiConverterOptionString.write(value.topicOwnerId, into: &buf)
        FfiConverterOptionString.write(value.topicCreatedAt, into: &buf)
        FfiConverterOptionSequenceTypeTag.write(value.tags, into: &buf)
        FfiConverterInt64.write(value.cachedAt, into: &buf)
        FfiConverterBool.write(value.isPartial, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConversation_lift(_ buf: RustBuffer) throws -> Conversation {
    return try FfiConverterTypeConversation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConversation_lower(_ value: Conversation) -> RustBuffer {
    return FfiConverterTypeConversation.lower(value)
}


public struct GetChatLogsResult {
    public var hasMore: Bool
    public var startSeq: Int64
    public var endSeq: Int64
    public var items: [ChatLog]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(hasMore: Bool, startSeq: Int64, endSeq: Int64, items: [ChatLog]) {
        self.hasMore = hasMore
        self.startSeq = startSeq
        self.endSeq = endSeq
        self.items = items
    }
}

#if compiler(>=6)
extension GetChatLogsResult: Sendable {}
#endif


extension GetChatLogsResult: Equatable, Hashable {
    public static func ==(lhs: GetChatLogsResult, rhs: GetChatLogsResult) -> Bool {
        if lhs.hasMore != rhs.hasMore {
            return false
        }
        if lhs.startSeq != rhs.startSeq {
            return false
        }
        if lhs.endSeq != rhs.endSeq {
            return false
        }
        if lhs.items != rhs.items {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(hasMore)
        hasher.combine(startSeq)
        hasher.combine(endSeq)
        hasher.combine(items)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetChatLogsResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetChatLogsResult {
        return
            try GetChatLogsResult(
                hasMore: FfiConverterBool.read(from: &buf), 
                startSeq: FfiConverterInt64.read(from: &buf), 
                endSeq: FfiConverterInt64.read(from: &buf), 
                items: FfiConverterSequenceTypeChatLog.read(from: &buf)
        )
    }

    public static func write(_ value: GetChatLogsResult, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.hasMore, into: &buf)
        FfiConverterInt64.write(value.startSeq, into: &buf)
        FfiConverterInt64.write(value.endSeq, into: &buf)
        FfiConverterSequenceTypeChatLog.write(value.items, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetChatLogsResult_lift(_ buf: RustBuffer) throws -> GetChatLogsResult {
    return try FfiConverterTypeGetChatLogsResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetChatLogsResult_lower(_ value: GetChatLogsResult) -> RustBuffer {
    return FfiConverterTypeGetChatLogsResult.lower(value)
}


public struct ListUserResult {
    public var hasMore: Bool
    public var updatedAt: String
    public var items: [User]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(hasMore: Bool, updatedAt: String, items: [User]) {
        self.hasMore = hasMore
        self.updatedAt = updatedAt
        self.items = items
    }
}

#if compiler(>=6)
extension ListUserResult: Sendable {}
#endif


extension ListUserResult: Equatable, Hashable {
    public static func ==(lhs: ListUserResult, rhs: ListUserResult) -> Bool {
        if lhs.hasMore != rhs.hasMore {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        if lhs.items != rhs.items {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(hasMore)
        hasher.combine(updatedAt)
        hasher.combine(items)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListUserResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListUserResult {
        return
            try ListUserResult(
                hasMore: FfiConverterBool.read(from: &buf), 
                updatedAt: FfiConverterString.read(from: &buf), 
                items: FfiConverterSequenceTypeUser.read(from: &buf)
        )
    }

    public static func write(_ value: ListUserResult, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.hasMore, into: &buf)
        FfiConverterString.write(value.updatedAt, into: &buf)
        FfiConverterSequenceTypeUser.write(value.items, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListUserResult_lift(_ buf: RustBuffer) throws -> ListUserResult {
    return try FfiConverterTypeListUserResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListUserResult_lower(_ value: ListUserResult) -> RustBuffer {
    return FfiConverterTypeListUserResult.lower(value)
}


public struct Tag {
    public var id: String
    public var tagType: String
    public var label: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, tagType: String, label: String) {
        self.id = id
        self.tagType = tagType
        self.label = label
    }
}

#if compiler(>=6)
extension Tag: Sendable {}
#endif


extension Tag: Equatable, Hashable {
    public static func ==(lhs: Tag, rhs: Tag) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.tagType != rhs.tagType {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(tagType)
        hasher.combine(label)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTag: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Tag {
        return
            try Tag(
                id: FfiConverterString.read(from: &buf), 
                tagType: FfiConverterString.read(from: &buf), 
                label: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Tag, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.tagType, into: &buf)
        FfiConverterString.write(value.label, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTag_lift(_ buf: RustBuffer) throws -> Tag {
    return try FfiConverterTypeTag.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTag_lower(_ value: Tag) -> RustBuffer {
    return FfiConverterTypeTag.lower(value)
}


public struct Topic {
    public var id: String
    public var name: String
    public var icon: String
    public var remark: String
    public var ownerId: String
    public var attendeeId: String
    public var admins: [String]
    public var members: UInt32
    public var lastSeq: Int64
    public var multiple: Bool
    public var source: String
    public var `private`: Bool
    public var createdAt: String
    public var updatedAt: String
    public var notice: TopicNotice?
    public var extra: [String: String]?
    public var silent: Bool
    public var cachedAt: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, name: String, icon: String, remark: String, ownerId: String, attendeeId: String, admins: [String], members: UInt32, lastSeq: Int64, multiple: Bool, source: String, `private`: Bool, createdAt: String, updatedAt: String, notice: TopicNotice?, extra: [String: String]?, silent: Bool, cachedAt: Int64) {
        self.id = id
        self.name = name
        self.icon = icon
        self.remark = remark
        self.ownerId = ownerId
        self.attendeeId = attendeeId
        self.admins = admins
        self.members = members
        self.lastSeq = lastSeq
        self.multiple = multiple
        self.source = source
        self.`private` = `private`
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.notice = notice
        self.extra = extra
        self.silent = silent
        self.cachedAt = cachedAt
    }
}

#if compiler(>=6)
extension Topic: Sendable {}
#endif


extension Topic: Equatable, Hashable {
    public static func ==(lhs: Topic, rhs: Topic) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.icon != rhs.icon {
            return false
        }
        if lhs.remark != rhs.remark {
            return false
        }
        if lhs.ownerId != rhs.ownerId {
            return false
        }
        if lhs.attendeeId != rhs.attendeeId {
            return false
        }
        if lhs.admins != rhs.admins {
            return false
        }
        if lhs.members != rhs.members {
            return false
        }
        if lhs.lastSeq != rhs.lastSeq {
            return false
        }
        if lhs.multiple != rhs.multiple {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        if lhs.`private` != rhs.`private` {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        if lhs.notice != rhs.notice {
            return false
        }
        if lhs.extra != rhs.extra {
            return false
        }
        if lhs.silent != rhs.silent {
            return false
        }
        if lhs.cachedAt != rhs.cachedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(icon)
        hasher.combine(remark)
        hasher.combine(ownerId)
        hasher.combine(attendeeId)
        hasher.combine(admins)
        hasher.combine(members)
        hasher.combine(lastSeq)
        hasher.combine(multiple)
        hasher.combine(source)
        hasher.combine(`private`)
        hasher.combine(createdAt)
        hasher.combine(updatedAt)
        hasher.combine(notice)
        hasher.combine(extra)
        hasher.combine(silent)
        hasher.combine(cachedAt)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTopic: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Topic {
        return
            try Topic(
                id: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                icon: FfiConverterString.read(from: &buf), 
                remark: FfiConverterString.read(from: &buf), 
                ownerId: FfiConverterString.read(from: &buf), 
                attendeeId: FfiConverterString.read(from: &buf), 
                admins: FfiConverterSequenceString.read(from: &buf), 
                members: FfiConverterUInt32.read(from: &buf), 
                lastSeq: FfiConverterInt64.read(from: &buf), 
                multiple: FfiConverterBool.read(from: &buf), 
                source: FfiConverterString.read(from: &buf), 
                private: FfiConverterBool.read(from: &buf), 
                createdAt: FfiConverterString.read(from: &buf), 
                updatedAt: FfiConverterString.read(from: &buf), 
                notice: FfiConverterOptionTypeTopicNotice.read(from: &buf), 
                extra: FfiConverterOptionDictionaryStringString.read(from: &buf), 
                silent: FfiConverterBool.read(from: &buf), 
                cachedAt: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Topic, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.icon, into: &buf)
        FfiConverterString.write(value.remark, into: &buf)
        FfiConverterString.write(value.ownerId, into: &buf)
        FfiConverterString.write(value.attendeeId, into: &buf)
        FfiConverterSequenceString.write(value.admins, into: &buf)
        FfiConverterUInt32.write(value.members, into: &buf)
        FfiConverterInt64.write(value.lastSeq, into: &buf)
        FfiConverterBool.write(value.multiple, into: &buf)
        FfiConverterString.write(value.source, into: &buf)
        FfiConverterBool.write(value.`private`, into: &buf)
        FfiConverterString.write(value.createdAt, into: &buf)
        FfiConverterString.write(value.updatedAt, into: &buf)
        FfiConverterOptionTypeTopicNotice.write(value.notice, into: &buf)
        FfiConverterOptionDictionaryStringString.write(value.extra, into: &buf)
        FfiConverterBool.write(value.silent, into: &buf)
        FfiConverterInt64.write(value.cachedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTopic_lift(_ buf: RustBuffer) throws -> Topic {
    return try FfiConverterTypeTopic.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTopic_lower(_ value: Topic) -> RustBuffer {
    return FfiConverterTypeTopic.lower(value)
}


public struct TopicKnock {
    public var createdAt: String
    public var updatedAt: String
    public var topicId: String
    public var userId: String
    public var message: String
    public var source: String
    public var status: String
    public var adminId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(createdAt: String, updatedAt: String, topicId: String, userId: String, message: String, source: String, status: String, adminId: String) {
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.topicId = topicId
        self.userId = userId
        self.message = message
        self.source = source
        self.status = status
        self.adminId = adminId
    }
}

#if compiler(>=6)
extension TopicKnock: Sendable {}
#endif


extension TopicKnock: Equatable, Hashable {
    public static func ==(lhs: TopicKnock, rhs: TopicKnock) -> Bool {
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        if lhs.topicId != rhs.topicId {
            return false
        }
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.adminId != rhs.adminId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(createdAt)
        hasher.combine(updatedAt)
        hasher.combine(topicId)
        hasher.combine(userId)
        hasher.combine(message)
        hasher.combine(source)
        hasher.combine(status)
        hasher.combine(adminId)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTopicKnock: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TopicKnock {
        return
            try TopicKnock(
                createdAt: FfiConverterString.read(from: &buf), 
                updatedAt: FfiConverterString.read(from: &buf), 
                topicId: FfiConverterString.read(from: &buf), 
                userId: FfiConverterString.read(from: &buf), 
                message: FfiConverterString.read(from: &buf), 
                source: FfiConverterString.read(from: &buf), 
                status: FfiConverterString.read(from: &buf), 
                adminId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: TopicKnock, into buf: inout [UInt8]) {
        FfiConverterString.write(value.createdAt, into: &buf)
        FfiConverterString.write(value.updatedAt, into: &buf)
        FfiConverterString.write(value.topicId, into: &buf)
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
        FfiConverterString.write(value.source, into: &buf)
        FfiConverterString.write(value.status, into: &buf)
        FfiConverterString.write(value.adminId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTopicKnock_lift(_ buf: RustBuffer) throws -> TopicKnock {
    return try FfiConverterTypeTopicKnock.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTopicKnock_lower(_ value: TopicKnock) -> RustBuffer {
    return FfiConverterTypeTopicKnock.lower(value)
}


public struct TopicMember {
    public var topicId: String
    public var userId: String
    public var name: String
    public var source: String
    public var silenceAt: String?
    public var joinedAt: String
    public var updatedAt: String
    public var extra: [String: String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(topicId: String, userId: String, name: String, source: String, silenceAt: String?, joinedAt: String, updatedAt: String, extra: [String: String]?) {
        self.topicId = topicId
        self.userId = userId
        self.name = name
        self.source = source
        self.silenceAt = silenceAt
        self.joinedAt = joinedAt
        self.updatedAt = updatedAt
        self.extra = extra
    }
}

#if compiler(>=6)
extension TopicMember: Sendable {}
#endif


extension TopicMember: Equatable, Hashable {
    public static func ==(lhs: TopicMember, rhs: TopicMember) -> Bool {
        if lhs.topicId != rhs.topicId {
            return false
        }
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        if lhs.silenceAt != rhs.silenceAt {
            return false
        }
        if lhs.joinedAt != rhs.joinedAt {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        if lhs.extra != rhs.extra {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(topicId)
        hasher.combine(userId)
        hasher.combine(name)
        hasher.combine(source)
        hasher.combine(silenceAt)
        hasher.combine(joinedAt)
        hasher.combine(updatedAt)
        hasher.combine(extra)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTopicMember: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TopicMember {
        return
            try TopicMember(
                topicId: FfiConverterString.read(from: &buf), 
                userId: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                source: FfiConverterString.read(from: &buf), 
                silenceAt: FfiConverterOptionString.read(from: &buf), 
                joinedAt: FfiConverterString.read(from: &buf), 
                updatedAt: FfiConverterString.read(from: &buf), 
                extra: FfiConverterOptionDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: TopicMember, into buf: inout [UInt8]) {
        FfiConverterString.write(value.topicId, into: &buf)
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.source, into: &buf)
        FfiConverterOptionString.write(value.silenceAt, into: &buf)
        FfiConverterString.write(value.joinedAt, into: &buf)
        FfiConverterString.write(value.updatedAt, into: &buf)
        FfiConverterOptionDictionaryStringString.write(value.extra, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTopicMember_lift(_ buf: RustBuffer) throws -> TopicMember {
    return try FfiConverterTypeTopicMember.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTopicMember_lower(_ value: TopicMember) -> RustBuffer {
    return FfiConverterTypeTopicMember.lower(value)
}


public struct TopicNotice {
    public var text: String
    public var publisher: String
    public var updatedAt: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(text: String, publisher: String, updatedAt: String) {
        self.text = text
        self.publisher = publisher
        self.updatedAt = updatedAt
    }
}

#if compiler(>=6)
extension TopicNotice: Sendable {}
#endif


extension TopicNotice: Equatable, Hashable {
    public static func ==(lhs: TopicNotice, rhs: TopicNotice) -> Bool {
        if lhs.text != rhs.text {
            return false
        }
        if lhs.publisher != rhs.publisher {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(text)
        hasher.combine(publisher)
        hasher.combine(updatedAt)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTopicNotice: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TopicNotice {
        return
            try TopicNotice(
                text: FfiConverterString.read(from: &buf), 
                publisher: FfiConverterString.read(from: &buf), 
                updatedAt: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: TopicNotice, into buf: inout [UInt8]) {
        FfiConverterString.write(value.text, into: &buf)
        FfiConverterString.write(value.publisher, into: &buf)
        FfiConverterString.write(value.updatedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTopicNotice_lift(_ buf: RustBuffer) throws -> TopicNotice {
    return try FfiConverterTypeTopicNotice.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTopicNotice_lower(_ value: TopicNotice) -> RustBuffer {
    return FfiConverterTypeTopicNotice.lower(value)
}


public struct Upload {
    public var path: String
    public var fileName: String
    public var thumbnail: String
    public var ext: String
    public var size: UInt64
    public var external: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(path: String, fileName: String, thumbnail: String, ext: String, size: UInt64, external: Bool) {
        self.path = path
        self.fileName = fileName
        self.thumbnail = thumbnail
        self.ext = ext
        self.size = size
        self.external = external
    }
}

#if compiler(>=6)
extension Upload: Sendable {}
#endif


extension Upload: Equatable, Hashable {
    public static func ==(lhs: Upload, rhs: Upload) -> Bool {
        if lhs.path != rhs.path {
            return false
        }
        if lhs.fileName != rhs.fileName {
            return false
        }
        if lhs.thumbnail != rhs.thumbnail {
            return false
        }
        if lhs.ext != rhs.ext {
            return false
        }
        if lhs.size != rhs.size {
            return false
        }
        if lhs.external != rhs.external {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(path)
        hasher.combine(fileName)
        hasher.combine(thumbnail)
        hasher.combine(ext)
        hasher.combine(size)
        hasher.combine(external)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUpload: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Upload {
        return
            try Upload(
                path: FfiConverterString.read(from: &buf), 
                fileName: FfiConverterString.read(from: &buf), 
                thumbnail: FfiConverterString.read(from: &buf), 
                ext: FfiConverterString.read(from: &buf), 
                size: FfiConverterUInt64.read(from: &buf), 
                external: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Upload, into buf: inout [UInt8]) {
        FfiConverterString.write(value.path, into: &buf)
        FfiConverterString.write(value.fileName, into: &buf)
        FfiConverterString.write(value.thumbnail, into: &buf)
        FfiConverterString.write(value.ext, into: &buf)
        FfiConverterUInt64.write(value.size, into: &buf)
        FfiConverterBool.write(value.external, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpload_lift(_ buf: RustBuffer) throws -> Upload {
    return try FfiConverterTypeUpload.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpload_lower(_ value: Upload) -> RustBuffer {
    return FfiConverterTypeUpload.lower(value)
}


public struct User {
    public var userId: String
    public var name: String
    public var avatar: String
    public var publicKey: String
    public var remark: String
    public var isContact: Bool
    public var isStar: Bool
    public var isBlocked: Bool
    public var locale: String
    public var city: String
    public var country: String
    public var source: String
    public var createdAt: String
    public var gender: String
    public var memo: String
    public var extra: [String: String]?
    public var isStaff: Bool
    public var cachedAt: Int64
    public var isPartial: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(userId: String, name: String, avatar: String, publicKey: String, remark: String, isContact: Bool, isStar: Bool, isBlocked: Bool, locale: String, city: String, country: String, source: String, createdAt: String, gender: String, memo: String, extra: [String: String]?, isStaff: Bool, cachedAt: Int64, isPartial: Bool) {
        self.userId = userId
        self.name = name
        self.avatar = avatar
        self.publicKey = publicKey
        self.remark = remark
        self.isContact = isContact
        self.isStar = isStar
        self.isBlocked = isBlocked
        self.locale = locale
        self.city = city
        self.country = country
        self.source = source
        self.createdAt = createdAt
        self.gender = gender
        self.memo = memo
        self.extra = extra
        self.isStaff = isStaff
        self.cachedAt = cachedAt
        self.isPartial = isPartial
    }
}

#if compiler(>=6)
extension User: Sendable {}
#endif


extension User: Equatable, Hashable {
    public static func ==(lhs: User, rhs: User) -> Bool {
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.avatar != rhs.avatar {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.remark != rhs.remark {
            return false
        }
        if lhs.isContact != rhs.isContact {
            return false
        }
        if lhs.isStar != rhs.isStar {
            return false
        }
        if lhs.isBlocked != rhs.isBlocked {
            return false
        }
        if lhs.locale != rhs.locale {
            return false
        }
        if lhs.city != rhs.city {
            return false
        }
        if lhs.country != rhs.country {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.gender != rhs.gender {
            return false
        }
        if lhs.memo != rhs.memo {
            return false
        }
        if lhs.extra != rhs.extra {
            return false
        }
        if lhs.isStaff != rhs.isStaff {
            return false
        }
        if lhs.cachedAt != rhs.cachedAt {
            return false
        }
        if lhs.isPartial != rhs.isPartial {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userId)
        hasher.combine(name)
        hasher.combine(avatar)
        hasher.combine(publicKey)
        hasher.combine(remark)
        hasher.combine(isContact)
        hasher.combine(isStar)
        hasher.combine(isBlocked)
        hasher.combine(locale)
        hasher.combine(city)
        hasher.combine(country)
        hasher.combine(source)
        hasher.combine(createdAt)
        hasher.combine(gender)
        hasher.combine(memo)
        hasher.combine(extra)
        hasher.combine(isStaff)
        hasher.combine(cachedAt)
        hasher.combine(isPartial)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUser: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> User {
        return
            try User(
                userId: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                avatar: FfiConverterString.read(from: &buf), 
                publicKey: FfiConverterString.read(from: &buf), 
                remark: FfiConverterString.read(from: &buf), 
                isContact: FfiConverterBool.read(from: &buf), 
                isStar: FfiConverterBool.read(from: &buf), 
                isBlocked: FfiConverterBool.read(from: &buf), 
                locale: FfiConverterString.read(from: &buf), 
                city: FfiConverterString.read(from: &buf), 
                country: FfiConverterString.read(from: &buf), 
                source: FfiConverterString.read(from: &buf), 
                createdAt: FfiConverterString.read(from: &buf), 
                gender: FfiConverterString.read(from: &buf), 
                memo: FfiConverterString.read(from: &buf), 
                extra: FfiConverterOptionDictionaryStringString.read(from: &buf), 
                isStaff: FfiConverterBool.read(from: &buf), 
                cachedAt: FfiConverterInt64.read(from: &buf), 
                isPartial: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: User, into buf: inout [UInt8]) {
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.avatar, into: &buf)
        FfiConverterString.write(value.publicKey, into: &buf)
        FfiConverterString.write(value.remark, into: &buf)
        FfiConverterBool.write(value.isContact, into: &buf)
        FfiConverterBool.write(value.isStar, into: &buf)
        FfiConverterBool.write(value.isBlocked, into: &buf)
        FfiConverterString.write(value.locale, into: &buf)
        FfiConverterString.write(value.city, into: &buf)
        FfiConverterString.write(value.country, into: &buf)
        FfiConverterString.write(value.source, into: &buf)
        FfiConverterString.write(value.createdAt, into: &buf)
        FfiConverterString.write(value.gender, into: &buf)
        FfiConverterString.write(value.memo, into: &buf)
        FfiConverterOptionDictionaryStringString.write(value.extra, into: &buf)
        FfiConverterBool.write(value.isStaff, into: &buf)
        FfiConverterInt64.write(value.cachedAt, into: &buf)
        FfiConverterBool.write(value.isPartial, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUser_lift(_ buf: RustBuffer) throws -> User {
    return try FfiConverterTypeUser.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUser_lower(_ value: User) -> RustBuffer {
    return FfiConverterTypeUser.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AttachmentStatus {
    
    case toUpload
    case toDownload
    case uploading
    case downloading
    case paused
    case done
    case failed
}


#if compiler(>=6)
extension AttachmentStatus: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAttachmentStatus: FfiConverterRustBuffer {
    typealias SwiftType = AttachmentStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttachmentStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .toUpload
        
        case 2: return .toDownload
        
        case 3: return .uploading
        
        case 4: return .downloading
        
        case 5: return .paused
        
        case 6: return .done
        
        case 7: return .failed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AttachmentStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .toUpload:
            writeInt(&buf, Int32(1))
        
        
        case .toDownload:
            writeInt(&buf, Int32(2))
        
        
        case .uploading:
            writeInt(&buf, Int32(3))
        
        
        case .downloading:
            writeInt(&buf, Int32(4))
        
        
        case .paused:
            writeInt(&buf, Int32(5))
        
        
        case .done:
            writeInt(&buf, Int32(6))
        
        
        case .failed:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttachmentStatus_lift(_ buf: RustBuffer) throws -> AttachmentStatus {
    return try FfiConverterTypeAttachmentStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAttachmentStatus_lower(_ value: AttachmentStatus) -> RustBuffer {
    return FfiConverterTypeAttachmentStatus.lower(value)
}


extension AttachmentStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ChatLogStatus {
    
    case uploading
    case sending
    case sent
    case downloading
    case received
    case read
    case sendFailed
}


#if compiler(>=6)
extension ChatLogStatus: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChatLogStatus: FfiConverterRustBuffer {
    typealias SwiftType = ChatLogStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChatLogStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .uploading
        
        case 2: return .sending
        
        case 3: return .sent
        
        case 4: return .downloading
        
        case 5: return .received
        
        case 6: return .read
        
        case 7: return .sendFailed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ChatLogStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .uploading:
            writeInt(&buf, Int32(1))
        
        
        case .sending:
            writeInt(&buf, Int32(2))
        
        
        case .sent:
            writeInt(&buf, Int32(3))
        
        
        case .downloading:
            writeInt(&buf, Int32(4))
        
        
        case .received:
            writeInt(&buf, Int32(5))
        
        
        case .read:
            writeInt(&buf, Int32(6))
        
        
        case .sendFailed:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChatLogStatus_lift(_ buf: RustBuffer) throws -> ChatLogStatus {
    return try FfiConverterTypeChatLogStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChatLogStatus_lower(_ value: ChatLogStatus) -> RustBuffer {
    return FfiConverterTypeChatLogStatus.lower(value)
}


extension ChatLogStatus: Equatable, Hashable {}




public enum ClientError {

    
    
    case InvalidPassword(message: String)
    
    case Forbidden(message: String)
    
    case TokenExpired(message: String)
    
    case NetworkBroken(message: String)
    
    case TopicNotFound(message: String)
    
    case TopicKnockNotFound(message: String)
    
    case ChatLogNotFound(message: String)
    
    case InvalidContent(message: String)
    
    case ConversationNotFound(message: String)
    
    case UserNotFound(message: String)
    
    case KickOffByOtherClient(message: String)
    
    case StdError(message: String)
    
    case WebsocketError(message: String)
    
    case Http(message: String)
    
    case UserCancel(message: String)
    
    case Storage(message: String)
    
    case Other(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClientError: FfiConverterRustBuffer {
    typealias SwiftType = ClientError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidPassword(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Forbidden(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .TokenExpired(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .NetworkBroken(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .TopicNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .TopicKnockNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .ChatLogNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .InvalidContent(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .ConversationNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .UserNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .KickOffByOtherClient(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .StdError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 13: return .WebsocketError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 14: return .Http(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 15: return .UserCancel(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 16: return .Storage(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 17: return .Other(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClientError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .InvalidPassword(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .Forbidden(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .TokenExpired(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .NetworkBroken(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .TopicNotFound(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .TopicKnockNotFound(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .ChatLogNotFound(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .InvalidContent(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .ConversationNotFound(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))
        case .UserNotFound(_ /* message is ignored*/):
            writeInt(&buf, Int32(10))
        case .KickOffByOtherClient(_ /* message is ignored*/):
            writeInt(&buf, Int32(11))
        case .StdError(_ /* message is ignored*/):
            writeInt(&buf, Int32(12))
        case .WebsocketError(_ /* message is ignored*/):
            writeInt(&buf, Int32(13))
        case .Http(_ /* message is ignored*/):
            writeInt(&buf, Int32(14))
        case .UserCancel(_ /* message is ignored*/):
            writeInt(&buf, Int32(15))
        case .Storage(_ /* message is ignored*/):
            writeInt(&buf, Int32(16))
        case .Other(_ /* message is ignored*/):
            writeInt(&buf, Int32(17))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientError_lift(_ buf: RustBuffer) throws -> ClientError {
    return try FfiConverterTypeClientError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientError_lower(_ value: ClientError) -> RustBuffer {
    return FfiConverterTypeClientError.lower(value)
}


extension ClientError: Equatable, Hashable {}



extension ClientError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public protocol CountableCallback: AnyObject {
    
    func isCountable(content: Content)  -> Bool
    
}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceCountableCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceCountableCallback] = [UniffiVTableCallbackInterfaceCountableCallback(
        isCountable: { (
            uniffiHandle: UInt64,
            content: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<Int8>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Bool in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCountableCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.isCountable(
                     content: try FfiConverterTypeContent_lift(content)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterBool.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceCountableCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface CountableCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitCountableCallback() {
    uniffi_restsend_sdk_fn_init_callback_vtable_countablecallback(UniffiCallbackInterfaceCountableCallback.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceCountableCallback {
    fileprivate static let handleMap = UniffiHandleMap<CountableCallback>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceCountableCallback : FfiConverter {
    typealias SwiftType = CountableCallback
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceCountableCallback_lift(_ handle: UInt64) throws -> CountableCallback {
    return try FfiConverterCallbackInterfaceCountableCallback.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceCountableCallback_lower(_ v: CountableCallback) -> UInt64 {
    return FfiConverterCallbackInterfaceCountableCallback.lower(v)
}




public protocol DownloadCallback: AnyObject {
    
    func onProgress(progress: UInt64, total: UInt64) 
    
    func onSuccess(url: String, fileName: String) 
    
    func onFail(e: ClientError) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceDownloadCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceDownloadCallback] = [UniffiVTableCallbackInterfaceDownloadCallback(
        onProgress: { (
            uniffiHandle: UInt64,
            progress: UInt64,
            total: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceDownloadCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onProgress(
                     progress: try FfiConverterUInt64.lift(progress),
                     total: try FfiConverterUInt64.lift(total)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onSuccess: { (
            uniffiHandle: UInt64,
            url: RustBuffer,
            fileName: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceDownloadCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onSuccess(
                     url: try FfiConverterString.lift(url),
                     fileName: try FfiConverterString.lift(fileName)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onFail: { (
            uniffiHandle: UInt64,
            e: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceDownloadCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onFail(
                     e: try FfiConverterTypeClientError_lift(e)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceDownloadCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface DownloadCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitDownloadCallback() {
    uniffi_restsend_sdk_fn_init_callback_vtable_downloadcallback(UniffiCallbackInterfaceDownloadCallback.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceDownloadCallback {
    fileprivate static let handleMap = UniffiHandleMap<DownloadCallback>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceDownloadCallback : FfiConverter {
    typealias SwiftType = DownloadCallback
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceDownloadCallback_lift(_ handle: UInt64) throws -> DownloadCallback {
    return try FfiConverterCallbackInterfaceDownloadCallback.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceDownloadCallback_lower(_ v: DownloadCallback) -> UInt64 {
    return FfiConverterCallbackInterfaceDownloadCallback.lower(v)
}




public protocol MessageCallback: AnyObject {
    
    func onSent(chatId: String) 
    
    func onProgress(progress: UInt64, total: UInt64) 
    
    func onAttachmentUpload(result: Upload)  -> Content?
    
    func onAck(req: ChatRequest) 
    
    func onFail(reason: String) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceMessageCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceMessageCallback] = [UniffiVTableCallbackInterfaceMessageCallback(
        onSent: { (
            uniffiHandle: UInt64,
            chatId: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceMessageCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onSent(
                     chatId: try FfiConverterString.lift(chatId)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onProgress: { (
            uniffiHandle: UInt64,
            progress: UInt64,
            total: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceMessageCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onProgress(
                     progress: try FfiConverterUInt64.lift(progress),
                     total: try FfiConverterUInt64.lift(total)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onAttachmentUpload: { (
            uniffiHandle: UInt64,
            result: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Content? in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceMessageCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onAttachmentUpload(
                     result: try FfiConverterTypeUpload_lift(result)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeContent.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onAck: { (
            uniffiHandle: UInt64,
            req: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceMessageCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onAck(
                     req: try FfiConverterTypeChatRequest_lift(req)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onFail: { (
            uniffiHandle: UInt64,
            reason: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceMessageCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onFail(
                     reason: try FfiConverterString.lift(reason)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceMessageCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface MessageCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitMessageCallback() {
    uniffi_restsend_sdk_fn_init_callback_vtable_messagecallback(UniffiCallbackInterfaceMessageCallback.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceMessageCallback {
    fileprivate static let handleMap = UniffiHandleMap<MessageCallback>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceMessageCallback : FfiConverter {
    typealias SwiftType = MessageCallback
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceMessageCallback_lift(_ handle: UInt64) throws -> MessageCallback {
    return try FfiConverterCallbackInterfaceMessageCallback.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceMessageCallback_lower(_ v: MessageCallback) -> UInt64 {
    return FfiConverterCallbackInterfaceMessageCallback.lower(v)
}




public protocol RsCallback: AnyObject {
    
    func onConnected() 
    
    func onConnecting() 
    
    func onTokenExpired(reason: String) 
    
    func onNetBroken(reason: String) 
    
    func onKickoffByOtherClient(reason: String) 
    
    func onSystemRequest(req: ChatRequest)  -> ChatRequest?
    
    func onUnknownRequest(req: ChatRequest)  -> ChatRequest?
    
    func onTopicTyping(topicId: String, message: String?) 
    
    func onNewMessage(topicId: String, message: ChatRequest)  -> ChatRequestStatus
    
    func onTopicRead(topicId: String, message: ChatRequest) 
    
    func onConversationsUpdated(conversations: [Conversation]) 
    
    func onConversationRemoved(conversationId: String) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceRsCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceRsCallback] = [UniffiVTableCallbackInterfaceRsCallback(
        onConnected: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onConnected(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onConnecting: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onConnecting(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onTokenExpired: { (
            uniffiHandle: UInt64,
            reason: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onTokenExpired(
                     reason: try FfiConverterString.lift(reason)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onNetBroken: { (
            uniffiHandle: UInt64,
            reason: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onNetBroken(
                     reason: try FfiConverterString.lift(reason)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onKickoffByOtherClient: { (
            uniffiHandle: UInt64,
            reason: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onKickoffByOtherClient(
                     reason: try FfiConverterString.lift(reason)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onSystemRequest: { (
            uniffiHandle: UInt64,
            req: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> ChatRequest? in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onSystemRequest(
                     req: try FfiConverterTypeChatRequest_lift(req)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeChatRequest.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onUnknownRequest: { (
            uniffiHandle: UInt64,
            req: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> ChatRequest? in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUnknownRequest(
                     req: try FfiConverterTypeChatRequest_lift(req)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeChatRequest.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onTopicTyping: { (
            uniffiHandle: UInt64,
            topicId: RustBuffer,
            message: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onTopicTyping(
                     topicId: try FfiConverterString.lift(topicId),
                     message: try FfiConverterOptionString.lift(message)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onNewMessage: { (
            uniffiHandle: UInt64,
            topicId: RustBuffer,
            message: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> ChatRequestStatus in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onNewMessage(
                     topicId: try FfiConverterString.lift(topicId),
                     message: try FfiConverterTypeChatRequest_lift(message)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeChatRequestStatus_lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onTopicRead: { (
            uniffiHandle: UInt64,
            topicId: RustBuffer,
            message: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onTopicRead(
                     topicId: try FfiConverterString.lift(topicId),
                     message: try FfiConverterTypeChatRequest_lift(message)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onConversationsUpdated: { (
            uniffiHandle: UInt64,
            conversations: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onConversationsUpdated(
                     conversations: try FfiConverterSequenceTypeConversation.lift(conversations)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onConversationRemoved: { (
            uniffiHandle: UInt64,
            conversationId: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onConversationRemoved(
                     conversationId: try FfiConverterString.lift(conversationId)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceRsCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface RsCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitRsCallback() {
    uniffi_restsend_sdk_fn_init_callback_vtable_rscallback(UniffiCallbackInterfaceRsCallback.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceRsCallback {
    fileprivate static let handleMap = UniffiHandleMap<RsCallback>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceRsCallback : FfiConverter {
    typealias SwiftType = RsCallback
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceRsCallback_lift(_ handle: UInt64) throws -> RsCallback {
    return try FfiConverterCallbackInterfaceRsCallback.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceRsCallback_lower(_ v: RsCallback) -> UInt64 {
    return FfiConverterCallbackInterfaceRsCallback.lower(v)
}




public protocol SyncChatLogsCallback: AnyObject {
    
    func onSuccess(r: GetChatLogsResult) 
    
    func onFail(e: ClientError) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSyncChatLogsCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceSyncChatLogsCallback] = [UniffiVTableCallbackInterfaceSyncChatLogsCallback(
        onSuccess: { (
            uniffiHandle: UInt64,
            r: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSyncChatLogsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onSuccess(
                     r: try FfiConverterTypeGetChatLogsResult_lift(r)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onFail: { (
            uniffiHandle: UInt64,
            e: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSyncChatLogsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onFail(
                     e: try FfiConverterTypeClientError_lift(e)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceSyncChatLogsCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface SyncChatLogsCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitSyncChatLogsCallback() {
    uniffi_restsend_sdk_fn_init_callback_vtable_syncchatlogscallback(UniffiCallbackInterfaceSyncChatLogsCallback.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceSyncChatLogsCallback {
    fileprivate static let handleMap = UniffiHandleMap<SyncChatLogsCallback>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceSyncChatLogsCallback : FfiConverter {
    typealias SwiftType = SyncChatLogsCallback
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSyncChatLogsCallback_lift(_ handle: UInt64) throws -> SyncChatLogsCallback {
    return try FfiConverterCallbackInterfaceSyncChatLogsCallback.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSyncChatLogsCallback_lower(_ v: SyncChatLogsCallback) -> UInt64 {
    return FfiConverterCallbackInterfaceSyncChatLogsCallback.lower(v)
}




public protocol SyncConversationsCallback: AnyObject {
    
    func onSuccess(updatedAt: String, lastRemovedAt: String?, count: UInt32) 
    
    func onFail(e: ClientError) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSyncConversationsCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceSyncConversationsCallback] = [UniffiVTableCallbackInterfaceSyncConversationsCallback(
        onSuccess: { (
            uniffiHandle: UInt64,
            updatedAt: RustBuffer,
            lastRemovedAt: RustBuffer,
            count: UInt32,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSyncConversationsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onSuccess(
                     updatedAt: try FfiConverterString.lift(updatedAt),
                     lastRemovedAt: try FfiConverterOptionString.lift(lastRemovedAt),
                     count: try FfiConverterUInt32.lift(count)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onFail: { (
            uniffiHandle: UInt64,
            e: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSyncConversationsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onFail(
                     e: try FfiConverterTypeClientError_lift(e)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceSyncConversationsCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface SyncConversationsCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitSyncConversationsCallback() {
    uniffi_restsend_sdk_fn_init_callback_vtable_syncconversationscallback(UniffiCallbackInterfaceSyncConversationsCallback.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceSyncConversationsCallback {
    fileprivate static let handleMap = UniffiHandleMap<SyncConversationsCallback>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceSyncConversationsCallback : FfiConverter {
    typealias SwiftType = SyncConversationsCallback
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSyncConversationsCallback_lift(_ handle: UInt64) throws -> SyncConversationsCallback {
    return try FfiConverterCallbackInterfaceSyncConversationsCallback.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSyncConversationsCallback_lower(_ v: SyncConversationsCallback) -> UInt64 {
    return FfiConverterCallbackInterfaceSyncConversationsCallback.lower(v)
}




public protocol UploadCallback: AnyObject {
    
    func onProgress(progress: UInt64, total: UInt64) 
    
    func onSuccess(result: Upload) 
    
    func onFail(e: ClientError) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceUploadCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceUploadCallback] = [UniffiVTableCallbackInterfaceUploadCallback(
        onProgress: { (
            uniffiHandle: UInt64,
            progress: UInt64,
            total: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceUploadCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onProgress(
                     progress: try FfiConverterUInt64.lift(progress),
                     total: try FfiConverterUInt64.lift(total)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onSuccess: { (
            uniffiHandle: UInt64,
            result: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceUploadCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onSuccess(
                     result: try FfiConverterTypeUpload_lift(result)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onFail: { (
            uniffiHandle: UInt64,
            e: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceUploadCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onFail(
                     e: try FfiConverterTypeClientError_lift(e)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceUploadCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface UploadCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitUploadCallback() {
    uniffi_restsend_sdk_fn_init_callback_vtable_uploadcallback(UniffiCallbackInterfaceUploadCallback.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceUploadCallback {
    fileprivate static let handleMap = UniffiHandleMap<UploadCallback>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceUploadCallback : FfiConverter {
    typealias SwiftType = UploadCallback
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceUploadCallback_lift(_ handle: UInt64) throws -> UploadCallback {
    return try FfiConverterCallbackInterfaceUploadCallback.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceUploadCallback_lower(_ v: UploadCallback) -> UInt64 {
    return FfiConverterCallbackInterfaceUploadCallback.lower(v)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAttachment: FfiConverterRustBuffer {
    typealias SwiftType = Attachment?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAttachment.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAttachment.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAuthInfo: FfiConverterRustBuffer {
    typealias SwiftType = AuthInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAuthInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAuthInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeChatLog: FfiConverterRustBuffer {
    typealias SwiftType = ChatLog?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeChatLog.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeChatLog.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeChatRequest: FfiConverterRustBuffer {
    typealias SwiftType = ChatRequest?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeChatRequest.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeChatRequest.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeContent: FfiConverterRustBuffer {
    typealias SwiftType = Content?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeContent.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeContent.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeConversation: FfiConverterRustBuffer {
    typealias SwiftType = Conversation?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeConversation.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeConversation.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeGetChatLogsResult: FfiConverterRustBuffer {
    typealias SwiftType = GetChatLogsResult?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeGetChatLogsResult.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeGetChatLogsResult.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTopicNotice: FfiConverterRustBuffer {
    typealias SwiftType = TopicNotice?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTopicNotice.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTopicNotice.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeUser: FfiConverterRustBuffer {
    typealias SwiftType = User?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUser.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUser.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionCallbackInterfaceCountableCallback: FfiConverterRustBuffer {
    typealias SwiftType = CountableCallback?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceCountableCallback.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceCountableCallback.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionCallbackInterfaceMessageCallback: FfiConverterRustBuffer {
    typealias SwiftType = MessageCallback?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceMessageCallback.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceMessageCallback.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionCallbackInterfaceRsCallback: FfiConverterRustBuffer {
    typealias SwiftType = RsCallback?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceRsCallback.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceRsCallback.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeTag: FfiConverterRustBuffer {
    typealias SwiftType = [Tag]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeTag.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeTag.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeTopicKnock: FfiConverterRustBuffer {
    typealias SwiftType = [TopicKnock]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeTopicKnock.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeTopicKnock.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeUser: FfiConverterRustBuffer {
    typealias SwiftType = [User]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeUser.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeUser.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionDictionaryStringString: FfiConverterRustBuffer {
    typealias SwiftType = [String: String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeChatLog: FfiConverterRustBuffer {
    typealias SwiftType = [ChatLog]

    public static func write(_ value: [ChatLog], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeChatLog.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ChatLog] {
        let len: Int32 = try readInt(&buf)
        var seq = [ChatLog]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeChatLog.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeConversation: FfiConverterRustBuffer {
    typealias SwiftType = [Conversation]

    public static func write(_ value: [Conversation], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeConversation.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Conversation] {
        let len: Int32 = try readInt(&buf)
        var seq = [Conversation]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeConversation.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTag: FfiConverterRustBuffer {
    typealias SwiftType = [Tag]

    public static func write(_ value: [Tag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Tag] {
        let len: Int32 = try readInt(&buf)
        var seq = [Tag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTag.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTopicKnock: FfiConverterRustBuffer {
    typealias SwiftType = [TopicKnock]

    public static func write(_ value: [TopicKnock], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTopicKnock.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TopicKnock] {
        let len: Int32 = try readInt(&buf)
        var seq = [TopicKnock]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTopicKnock.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeUser: FfiConverterRustBuffer {
    typealias SwiftType = [User]

    public static func write(_ value: [User], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUser.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [User] {
        let len: Int32 = try readInt(&buf)
        var seq = [User]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUser.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringTypeConversation: FfiConverterRustBuffer {
    public static func write(_ value: [String: Conversation], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeConversation.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Conversation] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Conversation]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeConversation.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call the ensure init function since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureRestsendSdkInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
public func getCurrentUser(root: String) -> AuthInfo?  {
    return try!  FfiConverterOptionTypeAuthInfo.lift(try! rustCall() {
    uniffi_restsend_sdk_fn_func_get_current_user(
        FfiConverterString.lower(root),$0
    )
})
}
public func guestLogin(endpoint: String, guestId: String, extra: [String: String]?)async throws  -> AuthInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_func_guest_login(FfiConverterString.lower(endpoint),FfiConverterString.lower(guestId),FfiConverterOptionDictionaryStringString.lower(extra)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeAuthInfo_lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
public func initLog(level: String, isTest: Bool)  {try! rustCall() {
    uniffi_restsend_sdk_fn_func_init_log(
        FfiConverterString.lower(level),
        FfiConverterBool.lower(isTest),$0
    )
}
}
public func loginWithPassword(endpoint: String, email: String, password: String)async throws  -> AuthInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_func_login_with_password(FfiConverterString.lower(endpoint),FfiConverterString.lower(email),FfiConverterString.lower(password)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeAuthInfo_lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
public func loginWithToken(endpoint: String, email: String, token: String)async throws  -> AuthInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_func_login_with_token(FfiConverterString.lower(endpoint),FfiConverterString.lower(email),FfiConverterString.lower(token)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeAuthInfo_lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
public func logout(endpoint: String, token: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_func_logout(FfiConverterString.lower(endpoint),FfiConverterString.lower(token)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
public func setCurrentUser(root: String, userId: String)throws   {try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_restsend_sdk_fn_func_set_current_user(
        FfiConverterString.lower(root),
        FfiConverterString.lower(userId),$0
    )
}
}
public func signup(endpoint: String, email: String, password: String)async throws  -> AuthInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_func_signup(FfiConverterString.lower(endpoint),FfiConverterString.lower(email),FfiConverterString.lower(password)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeAuthInfo_lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_restsend_sdk_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_restsend_sdk_checksum_func_get_current_user() != 38664) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_func_guest_login() != 52093) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_func_init_log() != 7959) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_func_login_with_password() != 30472) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_func_login_with_token() != 17192) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_func_logout() != 46886) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_func_set_current_user() != 52163) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_func_signup() != 41913) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_accept_topic_join() != 958) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_add_topic_admin() != 31818) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_add_topic_member() != 19050) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_app_active() != 57527) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_batch_sync_chatlogs() != 25823) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_cancel_send() != 52791) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_clean_messages() != 59978) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_clear_conversation() != 1217) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_connect() != 32058) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_connection_status() != 43467) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_create_chat() != 35001) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_create_topic() != 10272) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_decline_topic_join() != 32986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_dismiss_topic() != 31429) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_read() != 27645) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_recall() != 54883) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_send() != 63970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_send_file() != 24486) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_send_image() != 57206) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_send_invite() != 48621) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_send_link() != 47231) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_send_location() != 53102) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_send_logs() != 25609) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_send_text() != 58543) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_send_video() != 51717) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_send_voice() != 2843) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_typing() != 22676) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_update_extra() != 49966) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_download_file() != 20251) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_fetch_chat_logs_desc() != 26657) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_get_chat_log() != 48877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_get_conversation() != 705) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_get_topic() != 2719) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_get_topic_admins() != 35381) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_get_topic_knocks() != 14722) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_get_topic_members() != 28923) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_get_topic_owner() != 4067) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_get_unread_count() != 5267) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_get_user() != 38725) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_get_users() != 18858) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_join_topic() != 23281) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_quit_topic() != 61905) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_remove_conversation() != 62637) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_remove_messages() != 12198) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_remove_topic_admin() != 28399) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_remove_topic_member() != 59825) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_save_chat_logs() != 17817) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_search_chat_log() != 34514) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_send_chat_request() != 27229) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_send_chat_request_via_connection() != 44947) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_all_conversations_read() != 34161) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_allow_guest_chat() != 23795) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_callback() != 6096) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_conversation_extra() != 26768) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_conversation_mute() != 4062) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_conversation_read() != 59338) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_conversation_remark() != 1179) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_conversation_sticky() != 21777) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_conversation_tags() != 42761) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_countable_callback() != 30301) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_keepalive_interval_secs() != 15153) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_user_block() != 55547) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_user_remark() != 42283) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_user_star() != 31550) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_shutdown() != 4562) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_silent_topic() != 25014) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_silent_topic_member() != 49737) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_sync_chat_logs() != 58755) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_sync_conversations() != 65129) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_transfer_topic() != 22182) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_try_sync_chat_logs() != 8690) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_update_topic() != 54199) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_update_topic_notice() != 35344) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_constructor_client_new() != 32894) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_countablecallback_is_countable() != 49760) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_downloadcallback_on_progress() != 34732) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_downloadcallback_on_success() != 54544) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_downloadcallback_on_fail() != 1622) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_messagecallback_on_sent() != 7537) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_messagecallback_on_progress() != 60426) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_messagecallback_on_attachment_upload() != 36698) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_messagecallback_on_ack() != 21639) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_messagecallback_on_fail() != 37998) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_rscallback_on_connected() != 13965) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_rscallback_on_connecting() != 58584) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_rscallback_on_token_expired() != 15429) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_rscallback_on_net_broken() != 46993) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_rscallback_on_kickoff_by_other_client() != 3853) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_rscallback_on_system_request() != 65490) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_rscallback_on_unknown_request() != 27498) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_rscallback_on_topic_typing() != 43789) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_rscallback_on_new_message() != 31436) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_rscallback_on_topic_read() != 9031) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_rscallback_on_conversations_updated() != 23679) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_rscallback_on_conversation_removed() != 40106) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_syncchatlogscallback_on_success() != 7604) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_syncchatlogscallback_on_fail() != 6877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_syncconversationscallback_on_success() != 9765) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_syncconversationscallback_on_fail() != 18218) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_uploadcallback_on_progress() != 44211) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_uploadcallback_on_success() != 20539) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_uploadcallback_on_fail() != 38198) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitCountableCallback()
    uniffiCallbackInitDownloadCallback()
    uniffiCallbackInitMessageCallback()
    uniffiCallbackInitRsCallback()
    uniffiCallbackInitSyncChatLogsCallback()
    uniffiCallbackInitSyncConversationsCallback()
    uniffiCallbackInitUploadCallback()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureRestsendSdkInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all